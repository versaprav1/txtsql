2025-05-11 19:26:39,306 - INFO - QUERY START: list all the interfaces
2025-05-11 19:26:39,308 - INFO - QUERY ID: 1746984399-360197
2025-05-11 19:26:39,309 - INFO - START TIME: 2025-05-11 19:26:39.235200
2025-05-11 19:26:39,310 - INFO - Starting workflow execution for: 'list all the interfaces'
2025-05-11 19:26:39,318 - INFO - Initial state validated successfully
2025-05-11 19:26:39,319 - INFO - Using recursion limit: 40
2025-05-11 19:26:39,321 - INFO - Starting workflow stream
2025-05-11 19:26:39,333 - DEBUG - STDOUT: 
==== PLANNER NODE START ====
2025-05-11 19:26:39,335 - DEBUG - STDOUT: Input state: user_question=list all the interfaces
2025-05-11 19:26:39,342 - DEBUG - STDOUT: Current execution path: []
2025-05-11 19:26:39,345 - DEBUG - STDOUT: Processing user question: 'list all the interfaces'
2025-05-11 19:26:39,347 - DEBUG - STDOUT: Error initializing database services: name 'DatabaseMetadataStore' is not defined
2025-05-11 19:26:39,482 - DEBUG - STDERR: Traceback (most recent call last):
2025-05-11 19:26:39,484 - DEBUG - STDERR:   File "D:\versa\project_Files\txtsql\agents\agents.py", line 394, in __init__
    self.metadata_store = DatabaseMetadataStore()
2025-05-11 19:26:39,486 - DEBUG - STDERR: NameError: name 'DatabaseMetadataStore' is not defined
2025-05-11 19:26:39,535 - DEBUG - STDOUT: Successfully initialized PlannerAgent with database capabilities using model=chatgpt-4o-latest, server=openai
2025-05-11 19:26:39,542 - DEBUG - STDOUT: PlannerAgent is using LLM to analyze the query and determine the appropriate database tables and columns
2025-05-11 19:26:39,545 - DEBUG - STDOUT: Invoking PlannerAgent with question: 'list all the interfaces'
2025-05-11 19:26:39,547 - DEBUG - STDOUT: Error in PlannerAgent.invoke: OpenAI API key not found in config or environment variables
2025-05-11 19:26:39,785 - DEBUG - STDERR: Traceback (most recent call last):
2025-05-11 19:26:39,786 - DEBUG - STDERR:   File "D:\versa\project_Files\txtsql\agents\agents.py", line 886, in invoke
    model = self.get_model(json_model=True)
2025-05-11 19:26:39,789 - DEBUG - STDERR:   File "D:\versa\project_Files\txtsql\agents\agents.py", line 79, in get_model
    return CustomOpenAIWrapper(model=self.model, temperature=self.temperature, response_format={"type": "json_object"})
2025-05-11 19:26:39,792 - DEBUG - STDERR:   File "D:\versa\project_Files\txtsql\models\openai_models.py", line 65, in __init__
    self.client = get_client()  # Get client when needed
2025-05-11 19:26:39,795 - DEBUG - STDERR:   File "D:\versa\project_Files\txtsql\models\openai_models.py", line 25, in get_client
    raise ValueError("OpenAI API key not found in config or environment variables")
2025-05-11 19:26:39,798 - DEBUG - STDERR: ValueError: OpenAI API key not found in config or environment variables
2025-05-11 19:26:39,970 - DEBUG - STDOUT: PlannerAgent returned plan: {
  "error_type": "NON_FATAL",
  "error_message": "OpenAI API key not found in config or environment variables",
  "timestamp": "2025-05-11T19:26:39.801474",
  "stack_trace": "Traceback (most recent call last):\n  File \"D:\\versa\\project_Files\\txtsql\\agents\\agents.py\", line 886, in invoke\n    model = self.get_model(json_model=True)\n  File \"D:\\versa\\project_Files\\txtsql\\agents\\agents.py\", line 79, in get_model\n    return CustomOpenAIWrapper(model=self.model, temperature=self.temperature, response_format={\"type\": \"json_object\"})\n  File \"D:\\versa\\project_Files\\txtsql\\models\\openai_models.py\", line 65, in __init__\n    self.client = get_client()  # Get client when needed\n  File \"D:\\versa\\project_Files\\txtsql\\models\\openai_models.py\", line 25, in get_client\n    raise ValueError(\"OpenAI API key not found in config or environment variables\")\nValueError: OpenAI API key not found in config or environment variables\n",
  "component": "PlannerAgent",
  "state": {},
  "recommendations": [
    "Review error logs for more details",
    "Check state values for inconsistencies",
    "Contact support if issue persists"
  ]
}
2025-05-11 19:26:39,982 - DEBUG - STDOUT: Planner node output: current_agent=selector
2025-05-11 19:26:39,984 - DEBUG - STDOUT: Planner response being sent to selector: {
  "error_type": "NON_FATAL",
  "error_message": "OpenAI API key not found in config or environment variables",
  "timestamp": "2025-05-11T19:26:39.801474",
  "stack_trace": "Traceback (most recent call last):\n  File \"D:\\versa\\project_Files\\txtsql\\agents\\agents.py\", line 886, in invoke\n    model = self.get_model(json_model=True)\n  File \"D:\\versa\\project_Files\\txtsql\\agents\\agents.py\", line 79, in get_model\n    return CustomOpenAIWrapper(model=self.model, temperature=self.temperature, response_format={\"type\": \"json_object\"})\n  File \"D:\\versa\\project_Files\\txtsql\\models\\openai_models.py\", line 65, in __init__\n    self.client = get_client()  # Get client when needed\n  File \"D:\\versa\\project_Files\\txtsql\\models\\openai_models.py\", line 25, in get_client\n    raise ValueError(\"OpenAI API key not found in config or environment variables\")\nValueError: OpenAI API key not found in config or environment variables\n",
  "component": "PlannerAgent",
  "state": {},
  "recommendations": [
    "Review error logs for more details",
    "Check state values for inconsistencies",
    "Contact support if issue persists"
  ]
}
2025-05-11 19:26:39,996 - DEBUG - STDOUT: ==== PLANNER NODE END ====
2025-05-11 19:26:40,005 - INFO - Processing agent: planner
2025-05-11 19:26:40,010 - DEBUG - Event type: <class 'langgraph.pregel.io.AddableUpdatesDict'>
2025-05-11 19:26:40,011 - DEBUG - Event keys: dict_keys(['planner'])
2025-05-11 19:26:40,012 - DEBUG - Execution path: ['planner']
2025-05-11 19:26:40,013 - DEBUG - planner response: {'error_type': 'NON_FATAL', 'error_message': 'OpenAI API key not found in config or environment variables', 'timestamp': '2025-05-11T19:26:39.801474', 'stack_trace': 'Traceback (most recent call last):\n  File "D:\\versa\\project_Files\\txtsql\\agents\\agents.py", line 886, in invoke\n    model = self.get_model(json_model=True)\n  File "D:\\versa\\project_Files\\txtsql\\agents\\agents.py", line 79, in get_model\n    return CustomOpenAIWrapper(model=self.model, temperature=self.temperature, response_format={"type": "json_object"})\n  File "D:\\versa\\project_Files\\txtsql\\models\\openai_models.py", line 65, in __init__\n    self.client = get_client()  # Get client when needed\n  File "D:\\versa\\project_Files\\txtsql\\models\\openai_models.py", line 25, in get_client\n    raise ValueError("OpenAI API key not found in config or environment variables")\nValueError: OpenAI API key not found in config or environment variables\n', 'component': 'PlannerAgent', 'state': {}, 'recommendations': ['Review error logs for more details', 'Check state values for inconsistencies', 'Contact support if issue persists']}
2025-05-11 19:26:40,018 - DEBUG - STDOUT: 
==== SELECTOR NODE START ====
2025-05-11 19:26:40,022 - DEBUG - STDOUT: Input state: user_question=list all the interfaces
2025-05-11 19:26:40,025 - DEBUG - STDOUT: Current execution path: ['planner']
2025-05-11 19:26:40,027 - DEBUG - STDOUT: Planner response received: {
  "error_type": "NON_FATAL",
  "error_message": "OpenAI API key not found in config or environment variables",
  "timestamp": "2025-05-11T19:26:39.801474",
  "stack_trace": "Traceback (most recent call last):\n  File \"D:\\versa\\project_Files\\txtsql\\agents\\agents.py\", line 886, in invoke\n    model = self.get_model(json_model=True)\n  File \"D:\\versa\\project_Files\\txtsql\\agents\\agents.py\", line 79, in get_model\n    return CustomOpenAIWrapper(model=self.model, temperature=self.temperature, response_format={\"type\": \"json_object\"})\n  File \"D:\\versa\\project_Files\\txtsql\\models\\openai_models.py\", line 65, in __init__\n    self.client = get_client()  # Get client when needed\n  File \"D:\\versa\\project_Files\\txtsql\\models\\openai_models.py\", line 25, in get_client\n    raise ValueError(\"OpenAI API key not found in config or environment variables\")\nValueError: OpenAI API key not found in config or environment variables\n",
  "component": "PlannerAgent",
  "state": {},
  "recommendations": [
    "Review error logs for more details",
    "Check state values for inconsistencies",
    "Contact support if issue persists"
  ]
}
2025-05-11 19:26:40,040 - DEBUG - STDOUT: Selector is processing planner response for question: 'list all the interfaces'
2025-05-11 19:26:40,043 - DEBUG - STDOUT: NOTE: The selector node is currently simplified and doesn't use LLM.
2025-05-11 19:26:40,046 - DEBUG - STDOUT: It simply passes through to the SQLGenerator without making actual selections.
2025-05-11 19:26:40,059 - DEBUG - STDOUT: Selector node output: current_agent=SQLGenerator
2025-05-11 19:26:40,061 - DEBUG - STDOUT: Selector response being sent to SQLGenerator: {
  "raw": "Selection completed",
  "selected_schemas": {},
  "selected_tool": "sql_query",
  "selected_datasource": "information_schema.tables",
  "information_needed": "Table listing",
  "reason_for_selection": "Direct database query is the most efficient way to list tables",
  "query_parameters": {
    "columns": [
      "table_schema",
      "table_name"
    ],
    "filters": "table_type = 'BASE TABLE'"
  }
}
2025-05-11 19:26:40,077 - DEBUG - STDOUT: ==== SELECTOR NODE END ====
2025-05-11 19:26:40,092 - INFO - Processing agent: selector
2025-05-11 19:26:40,099 - DEBUG - Event type: <class 'langgraph.pregel.io.AddableUpdatesDict'>
2025-05-11 19:26:40,101 - DEBUG - Event keys: dict_keys(['selector'])
2025-05-11 19:26:40,107 - DEBUG - Execution path: ['planner', 'selector']
2025-05-11 19:26:40,110 - DEBUG - selector response: {'raw': 'Selection completed', 'selected_schemas': {}, 'selected_tool': 'sql_query', 'selected_datasource': 'information_schema.tables', 'information_needed': 'Table listing', 'reason_for_selection': 'Direct database query is the most efficient way to list tables', 'query_parameters': {'columns': ['table_schema', 'table_name'], 'filters': "table_type = 'BASE TABLE'"}}
2025-05-11 19:26:40,112 - DEBUG - STDOUT: 
==== SQL GENERATOR NODE START ====
2025-05-11 19:26:40,151 - DEBUG - STDOUT: Input state: user_question=list all the interfaces
2025-05-11 19:26:40,180 - DEBUG - STDOUT: Current execution path: ['planner', 'selector']
2025-05-11 19:26:40,190 - DEBUG - STDOUT: Selector response received: {
  "raw": "Selection completed",
  "selected_schemas": {},
  "selected_tool": "sql_query",
  "selected_datasource": "information_schema.tables",
  "information_needed": "Table listing",
  "reason_for_selection": "Direct database query is the most efficient way to list tables",
  "query_parameters": {
    "columns": [
      "table_schema",
      "table_name"
    ],
    "filters": "table_type = 'BASE TABLE'"
  }
}
2025-05-11 19:26:40,210 - DEBUG - STDOUT: Created SQLGenerator with model=chatgpt-4o-latest, server=openai
2025-05-11 19:26:40,213 - DEBUG - STDOUT: Invoking SQLGenerator with user_question: 'list all the interfaces'
2025-05-11 19:26:40,218 - DEBUG - STDOUT: SQLGenerator returned response: {
  "sql_generator_response": {
    "sql_query": "SELECT DISTINCT table_schema, table_name, column_name \n                FROM information_schema.columns \n                WHERE column_name ILIKE '%interface%'\n                AND table_schema NOT IN ('pg_catalog', 'information_schema')\n                ORDER BY table_schema, table_name;",
    "explanation": "Query to discover interface-related columns across all schemas",
    "validation_checks": [
      "Query syntax validated",
      "Schema and table specified",
      "Column list validated",
      "WHERE clause included",
      "Results limited for safety"
    ],
    "query_type": "interface_list",
    "estimated_complexity": "LOW",
    "required_indexes": [],
    "metadata": {
      "generated_at": "2025-05-11 19:26:40.218061",
      "validation_status": "valid",
      "has_limit": false,
      "has_order": true
    }
  }
}
2025-05-11 19:26:40,234 - DEBUG - STDOUT: SQL Generator node output: current_agent=reviewer
2025-05-11 19:26:40,241 - DEBUG - STDOUT: SQL query generated: SELECT DISTINCT table_schema, table_name, column_name 
                FROM information_schema.columns 
                WHERE column_name ILIKE '%interface%'
                AND table_schema NOT IN ('pg_catalog', 'information_schema')
                ORDER BY table_schema, table_name;
2025-05-11 19:26:40,246 - DEBUG - STDOUT: SQL Generator response being sent to reviewer: {
  "sql_generator_response": {
    "sql_query": "SELECT DISTINCT table_schema, table_name, column_name \n                FROM information_schema.columns \n                WHERE column_name ILIKE '%interface%'\n                AND table_schema NOT IN ('pg_catalog', 'information_schema')\n                ORDER BY table_schema, table_name;",
    "explanation": "Query to discover interface-related columns across all schemas",
    "validation_checks": [
      "Query syntax validated",
      "Schema and table specified",
      "Column list validated",
      "WHERE clause included",
      "Results limited for safety"
    ],
    "query_type": "interface_list",
    "estimated_complexity": "LOW",
    "required_indexes": [],
    "metadata": {
      "generated_at": "2025-05-11 19:26:40.218061",
      "validation_status": "valid",
      "has_limit": false,
      "has_order": true
    }
  }
}
2025-05-11 19:26:40,261 - DEBUG - STDOUT: ==== SQL GENERATOR NODE END ====
2025-05-11 19:26:40,266 - INFO - Processing agent: SQLGenerator
2025-05-11 19:26:40,269 - DEBUG - Event type: <class 'langgraph.pregel.io.AddableUpdatesDict'>
2025-05-11 19:26:40,276 - DEBUG - Event keys: dict_keys(['SQLGenerator'])
2025-05-11 19:26:40,278 - DEBUG - Execution path: ['planner', 'selector', 'SQLGenerator']
2025-05-11 19:26:40,279 - DEBUG - SQLGenerator response: {'sql_generator_response': {'sql_query': "SELECT DISTINCT table_schema, table_name, column_name \n                FROM information_schema.columns \n                WHERE column_name ILIKE '%interface%'\n                AND table_schema NOT IN ('pg_catalog', 'information_schema')\n                ORDER BY table_schema, table_name;", 'explanation': 'Query to discover interface-related columns across all schemas', 'validation_checks': ['Query syntax validated', 'Schema and table specified', 'Column list validated', 'WHERE clause included', 'Results limited for safety'], 'query_type': 'interface_list', 'estimated_complexity': 'LOW', 'required_indexes': [], 'metadata': {'generated_at': '2025-05-11 19:26:40.218061', 'validation_status': 'valid', 'has_limit': False, 'has_order': True}}}
2025-05-11 19:26:40,284 - DEBUG - STDOUT: 
==== REVIEWER NODE START ====
2025-05-11 19:26:40,291 - DEBUG - STDOUT: Input state: user_question=list all the interfaces
2025-05-11 19:26:40,294 - DEBUG - STDOUT: Current execution path: ['planner', 'selector', 'SQLGenerator']
2025-05-11 19:26:40,296 - DEBUG - STDOUT: SQL query to review: SELECT DISTINCT table_schema, table_name, column_name 
                FROM information_schema.columns 
                WHERE column_name ILIKE '%interface%'
                AND table_schema NOT IN ('pg_catalog', 'information_schema')
                ORDER BY table_schema, table_name;
2025-05-11 19:26:40,305 - DEBUG - STDOUT: SQLGenerator response received: {
  "sql_generator_response": {
    "sql_query": "SELECT DISTINCT table_schema, table_name, column_name \n                FROM information_schema.columns \n                WHERE column_name ILIKE '%interface%'\n                AND table_schema NOT IN ('pg_catalog', 'information_schema')\n                ORDER BY table_schema, table_name;",
    "explanation": "Query to discover interface-related columns across all schemas",
    "validation_checks": [
      "Query syntax validated",
      "Schema and table specified",
      "Column list validated",
      "WHERE clause included",
      "Results limited for safety"
    ],
    "query_type": "interface_list",
    "estimated_complexity": "LOW",
    "required_indexes": [],
    "metadata": {
      "generated_at": "2025-05-11 19:26:40.218061",
      "validation_status": "valid",
      "has_limit": false,
      "has_order": true
    }
  }
}
2025-05-11 19:26:40,319 - DEBUG - STDOUT: Reviewer is analyzing SQL query for question: 'list all the interfaces'
2025-05-11 19:26:40,327 - DEBUG - STDOUT: Using LLM-based ReviewerAgent to analyze the SQL query
2025-05-11 19:26:40,329 - DEBUG - STDOUT: Created ReviewerAgent with model=chatgpt-4o-latest, server=openai
2025-05-11 19:26:40,333 - DEBUG - STDOUT: Invoking ReviewerAgent with user_question: 'list all the interfaces' and sql_query: 'SELECT DISTINCT table_schema, table_name, column_name 
                FROM information_schema.columns 
                WHERE column_name ILIKE '%interface%'
                AND table_schema NOT IN ('pg_catalog', 'information_schema')
                ORDER BY table_schema, table_name;'
2025-05-11 19:26:40,345 - DEBUG - STDOUT: ReviewerAgent returned review: {
  "reviewer_response": {
    "is_correct": false,
    "issues": [
      "No LIMIT clause"
    ],
    "suggestions": [
      "Add LIMIT clause to prevent large result sets",
      "Ensure proper indexes exist for WHERE clause columns",
      "Consider adding indexes on WHERE clause columns",
      "Consider adding appropriate WHERE clauses",
      "Use explicit column names instead of *",
      "Add ORDER BY for consistent results"
    ],
    "explanation": "Query validation found issues: No LIMIT clause",
    "security_concerns": [],
    "performance_impact": "MEDIUM",
    "confidence_score": 1.0,
    "metadata": {
      "reviewed_at": "2025-05-11 19:26:40.344404",
      "query_type": "SELECT",
      "has_joins": false,
      "has_where": true,
      "has_limit": false
    }
  }
}
2025-05-11 19:26:40,364 - DEBUG - STDOUT: Reviewer node output: current_agent=sql_executor
2025-05-11 19:26:40,373 - DEBUG - STDOUT: Reviewer response being sent to sql_executor: {
  "reviewer_response": {
    "is_correct": false,
    "issues": [
      "No LIMIT clause"
    ],
    "suggestions": [
      "Add LIMIT clause to prevent large result sets",
      "Ensure proper indexes exist for WHERE clause columns",
      "Consider adding indexes on WHERE clause columns",
      "Consider adding appropriate WHERE clauses",
      "Use explicit column names instead of *",
      "Add ORDER BY for consistent results"
    ],
    "explanation": "Query validation found issues: No LIMIT clause",
    "security_concerns": [],
    "performance_impact": "MEDIUM",
    "confidence_score": 1.0,
    "metadata": {
      "reviewed_at": "2025-05-11 19:26:40.344404",
      "query_type": "SELECT",
      "has_joins": false,
      "has_where": true,
      "has_limit": false
    }
  }
}
2025-05-11 19:26:40,411 - DEBUG - STDOUT: ==== REVIEWER NODE END ====
2025-05-11 19:26:40,418 - INFO - Processing agent: reviewer
2025-05-11 19:26:40,430 - DEBUG - Event type: <class 'langgraph.pregel.io.AddableUpdatesDict'>
2025-05-11 19:26:40,433 - DEBUG - Event keys: dict_keys(['reviewer'])
2025-05-11 19:26:40,435 - DEBUG - Execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer']
2025-05-11 19:26:40,444 - DEBUG - reviewer response: {'reviewer_response': {'is_correct': False, 'issues': ['No LIMIT clause'], 'suggestions': ['Add LIMIT clause to prevent large result sets', 'Ensure proper indexes exist for WHERE clause columns', 'Consider adding indexes on WHERE clause columns', 'Consider adding appropriate WHERE clauses', 'Use explicit column names instead of *', 'Add ORDER BY for consistent results'], 'explanation': 'Query validation found issues: No LIMIT clause', 'security_concerns': [], 'performance_impact': 'MEDIUM', 'confidence_score': 1.0, 'metadata': {'reviewed_at': '2025-05-11 19:26:40.344404', 'query_type': 'SELECT', 'has_joins': False, 'has_where': True, 'has_limit': False}}}
2025-05-11 19:26:40,447 - DEBUG - STDOUT: 
==== SQL EXECUTOR NODE START ====
2025-05-11 19:26:40,450 - DEBUG - STDOUT: Input state: user_question=list all the interfaces
2025-05-11 19:26:40,451 - DEBUG - STDOUT: Current execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer']
2025-05-11 19:26:40,460 - DEBUG - STDOUT: SQL query to execute: SELECT DISTINCT table_schema, table_name, column_name 
                FROM information_schema.columns 
                WHERE column_name ILIKE '%interface%'
                AND table_schema NOT IN ('pg_catalog', 'information_schema')
                ORDER BY table_schema, table_name;
2025-05-11 19:26:40,463 - DEBUG - STDOUT: Reviewer response received: {
  "reviewer_response": {
    "is_correct": false,
    "issues": [
      "No LIMIT clause"
    ],
    "suggestions": [
      "Add LIMIT clause to prevent large result sets",
      "Ensure proper indexes exist for WHERE clause columns",
      "Consider adding indexes on WHERE clause columns",
      "Consider adding appropriate WHERE clauses",
      "Use explicit column names instead of *",
      "Add ORDER BY for consistent results"
    ],
    "explanation": "Query validation found issues: No LIMIT clause",
    "security_concerns": [],
    "performance_impact": "MEDIUM",
    "confidence_score": 1.0,
    "metadata": {
      "reviewed_at": "2025-05-11 19:26:40.344404",
      "query_type": "SELECT",
      "has_joins": false,
      "has_where": true,
      "has_limit": false
    }
  }
}
2025-05-11 19:26:40,478 - DEBUG - STDOUT: SQL Executor is processing SQL query: 'SELECT DISTINCT table_schema, table_name, column_name 
                FROM information_schema.columns 
                WHERE column_name ILIKE '%interface%'
                AND table_schema NOT IN ('pg_catalog', 'information_schema')
                ORDER BY table_schema, table_name;'
2025-05-11 19:26:41,589 - DEBUG - STDOUT: Executing SQL query against database: 'SELECT DISTINCT table_schema, table_name, column_name 
                FROM information_schema.columns 
                WHERE column_name ILIKE '%interface%'
                AND table_schema NOT IN ('pg_catalog', 'information_schema')
                ORDER BY table_schema, table_name;'
2025-05-11 19:26:41,593 - DEBUG - STDOUT: NOTE: SQL Executor does not use LLM. It directly executes the SQL query against the database.
2025-05-11 19:26:41,596 - DEBUG - STDOUT: Attempting database connection to localhost:5432/new as postgres
2025-05-11 19:26:41,667 - DEBUG - STDOUT: Successfully connected to database new at localhost:5432
2025-05-11 19:26:41,669 - DEBUG - STDOUT: Database is available
2025-05-11 19:26:41,670 - DEBUG - STDOUT: Attempting database connection to localhost:5432/new as postgres
2025-05-11 19:26:41,736 - DEBUG - STDOUT: Successfully connected to database new at localhost:5432
2025-05-11 19:26:41,836 - DEBUG - STDOUT: Successfully executed query against actual database
2025-05-11 19:26:41,837 - DEBUG - STDOUT: SQL query execution results: {
  "column_names": [
    "table_schema",
    "table_name",
    "column_name"
  ],
  "rows": [
    [
      "dev",
      "abap_integration_engine_interfaces",
      "abap_integration_engine_interface_destination"
    ],
    [
      "dev",
      "pro_agreements",
      "interface"
    ],
    [
      "dev",
      "pro_integrated_configuration_interfaces",
      "interface"
    ],
    [
      "dev",
      "pro_integrated_configuration_interfaces",
      "interface_namespace"
    ],
    [
      "dev",
      "pro_integrated_configuration_interfaces",
      "pro_integrated_configuration_interface_channel"
    ],
    [
      "dev",
      "pro_integrated_configuration_rules",
      "pro_integrated_configuration_interface_rules"
    ],
    [
      "dev",
      "pro_integrated_configurations",
      "interface"
    ],
    [
      "dev",
      "pro_performance_data",
      "interface_name"
    ],
    [
      "dev",
      "pro_performance_stats",
      "interface_name"
    ],
    [
      "dev",
      "system_mappings",
      "interface_pattern"
    ]
  ],
  "row_count": 10,
  "execution_time": 0.099152,
  "query": "SELECT DISTINCT table_schema, table_name, column_name \n                FROM information_schema.columns \n                WHERE column_name ILIKE '%interface%'\n                AND table_schema NOT IN ('pg_catalog', 'information_schema')\n                ORDER BY table_schema, table_name;",
  "status": "success"
}
2025-05-11 19:26:41,860 - DEBUG - STDOUT: SQL Executor node output: current_agent=router
2025-05-11 19:26:41,861 - DEBUG - STDOUT: SQL query results summary: status=success, rows=10
2025-05-11 19:26:41,862 - DEBUG - STDOUT: ==== SQL EXECUTOR NODE END ====
2025-05-11 19:26:41,865 - INFO - Processing agent: sql_executor
2025-05-11 19:26:41,866 - DEBUG - Event type: <class 'langgraph.pregel.io.AddableUpdatesDict'>
2025-05-11 19:26:41,866 - DEBUG - Event keys: dict_keys(['sql_executor'])
2025-05-11 19:26:41,867 - DEBUG - Execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor']
2025-05-11 19:26:41,868 - DEBUG - STDOUT: 
==== ROUTER NODE START ====
2025-05-11 19:26:41,870 - DEBUG - STDOUT: Input state: user_question=list all the interfaces
2025-05-11 19:26:41,871 - DEBUG - STDOUT: Current execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor']
2025-05-11 19:26:41,873 - DEBUG - STDOUT: RouterAgent returned decision: {
  "router_response": {
    "route_to": "planner",
    "reason": "Starting new workflow",
    "feedback": "Initializing workflow with planner",
    "state_updates": {
      "workflow_started": true,
      "start_time": "2025-05-11T19:26:41.873955"
    },
    "confidence_score": 1.0,
    "requires_human_input": false
  }
}
2025-05-11 19:26:41,879 - DEBUG - STDOUT: Route decision: planner
2025-05-11 19:26:41,882 - DEBUG - STDOUT: Router node output: current_agent=planner
2025-05-11 19:26:41,883 - DEBUG - STDOUT: Router response: {
  "route_to": "planner",
  "reason": "Starting new workflow",
  "feedback": "Initializing workflow with planner",
  "state_updates": {
    "workflow_started": true,
    "start_time": "2025-05-11T19:26:41.873955"
  },
  "confidence_score": 1.0,
  "requires_human_input": false
}
2025-05-11 19:26:41,888 - DEBUG - STDOUT: ==== ROUTER NODE END ====
2025-05-11 19:26:41,891 - DEBUG - STDOUT: ROUTE DECISION: planner -> to_planner
2025-05-11 19:26:41,895 - INFO - Processing agent: router
2025-05-11 19:26:41,897 - DEBUG - Event type: <class 'langgraph.pregel.io.AddableUpdatesDict'>
2025-05-11 19:26:41,897 - DEBUG - Event keys: dict_keys(['router'])
2025-05-11 19:26:41,898 - DEBUG - Execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router']
2025-05-11 19:26:41,898 - DEBUG - router response: {'route_to': 'planner', 'reason': 'Starting new workflow', 'feedback': 'Initializing workflow with planner', 'state_updates': {'workflow_started': True, 'start_time': '2025-05-11T19:26:41.873955'}, 'confidence_score': 1.0, 'requires_human_input': False}
2025-05-11 19:26:41,902 - DEBUG - STDOUT: 
==== PLANNER NODE START ====
2025-05-11 19:26:41,904 - DEBUG - STDOUT: Input state: user_question=list all the interfaces
2025-05-11 19:26:41,905 - DEBUG - STDOUT: Current execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router']
2025-05-11 19:26:41,906 - DEBUG - STDOUT: Processing user question: 'list all the interfaces'
2025-05-11 19:26:41,908 - DEBUG - STDOUT: Error initializing database services: name 'DatabaseMetadataStore' is not defined
2025-05-11 19:26:42,023 - DEBUG - STDERR: Traceback (most recent call last):
2025-05-11 19:26:42,038 - DEBUG - STDERR:   File "D:\versa\project_Files\txtsql\agents\agents.py", line 394, in __init__
    self.metadata_store = DatabaseMetadataStore()
2025-05-11 19:26:42,060 - DEBUG - STDERR: NameError: name 'DatabaseMetadataStore' is not defined
2025-05-11 19:26:42,062 - DEBUG - STDOUT: Successfully initialized PlannerAgent with database capabilities using model=chatgpt-4o-latest, server=openai
2025-05-11 19:26:42,064 - DEBUG - STDOUT: PlannerAgent is using LLM to analyze the query and determine the appropriate database tables and columns
2025-05-11 19:26:42,067 - DEBUG - STDOUT: Invoking PlannerAgent with question: 'list all the interfaces'
2025-05-11 19:26:42,072 - DEBUG - STDOUT: Error in PlannerAgent.invoke: OpenAI API key not found in config or environment variables
2025-05-11 19:26:42,228 - DEBUG - STDERR: Traceback (most recent call last):
2025-05-11 19:26:42,229 - DEBUG - STDERR:   File "D:\versa\project_Files\txtsql\agents\agents.py", line 886, in invoke
    model = self.get_model(json_model=True)
2025-05-11 19:26:42,232 - DEBUG - STDERR:   File "D:\versa\project_Files\txtsql\agents\agents.py", line 79, in get_model
    return CustomOpenAIWrapper(model=self.model, temperature=self.temperature, response_format={"type": "json_object"})
2025-05-11 19:26:42,234 - DEBUG - STDERR:   File "D:\versa\project_Files\txtsql\models\openai_models.py", line 65, in __init__
    self.client = get_client()  # Get client when needed
2025-05-11 19:26:42,236 - DEBUG - STDERR:   File "D:\versa\project_Files\txtsql\models\openai_models.py", line 25, in get_client
    raise ValueError("OpenAI API key not found in config or environment variables")
2025-05-11 19:26:42,238 - DEBUG - STDERR: ValueError: OpenAI API key not found in config or environment variables
2025-05-11 19:26:42,391 - DEBUG - STDOUT: PlannerAgent returned plan: {
  "error_type": "NON_FATAL",
  "error_message": "OpenAI API key not found in config or environment variables",
  "timestamp": "2025-05-11T19:26:42.241210",
  "stack_trace": "Traceback (most recent call last):\n  File \"D:\\versa\\project_Files\\txtsql\\agents\\agents.py\", line 886, in invoke\n    model = self.get_model(json_model=True)\n  File \"D:\\versa\\project_Files\\txtsql\\agents\\agents.py\", line 79, in get_model\n    return CustomOpenAIWrapper(model=self.model, temperature=self.temperature, response_format={\"type\": \"json_object\"})\n  File \"D:\\versa\\project_Files\\txtsql\\models\\openai_models.py\", line 65, in __init__\n    self.client = get_client()  # Get client when needed\n  File \"D:\\versa\\project_Files\\txtsql\\models\\openai_models.py\", line 25, in get_client\n    raise ValueError(\"OpenAI API key not found in config or environment variables\")\nValueError: OpenAI API key not found in config or environment variables\n",
  "component": "PlannerAgent",
  "state": {},
  "recommendations": [
    "Review error logs for more details",
    "Check state values for inconsistencies",
    "Contact support if issue persists"
  ]
}
2025-05-11 19:26:42,404 - DEBUG - STDOUT: Planner node output: current_agent=selector
2025-05-11 19:26:42,409 - DEBUG - STDOUT: Planner response being sent to selector: {
  "error_type": "NON_FATAL",
  "error_message": "OpenAI API key not found in config or environment variables",
  "timestamp": "2025-05-11T19:26:42.241210",
  "stack_trace": "Traceback (most recent call last):\n  File \"D:\\versa\\project_Files\\txtsql\\agents\\agents.py\", line 886, in invoke\n    model = self.get_model(json_model=True)\n  File \"D:\\versa\\project_Files\\txtsql\\agents\\agents.py\", line 79, in get_model\n    return CustomOpenAIWrapper(model=self.model, temperature=self.temperature, response_format={\"type\": \"json_object\"})\n  File \"D:\\versa\\project_Files\\txtsql\\models\\openai_models.py\", line 65, in __init__\n    self.client = get_client()  # Get client when needed\n  File \"D:\\versa\\project_Files\\txtsql\\models\\openai_models.py\", line 25, in get_client\n    raise ValueError(\"OpenAI API key not found in config or environment variables\")\nValueError: OpenAI API key not found in config or environment variables\n",
  "component": "PlannerAgent",
  "state": {},
  "recommendations": [
    "Review error logs for more details",
    "Check state values for inconsistencies",
    "Contact support if issue persists"
  ]
}
2025-05-11 19:26:42,427 - DEBUG - STDOUT: ==== PLANNER NODE END ====
2025-05-11 19:26:42,432 - INFO - Processing agent: planner
2025-05-11 19:26:42,435 - DEBUG - Event type: <class 'langgraph.pregel.io.AddableUpdatesDict'>
2025-05-11 19:26:42,437 - DEBUG - Event keys: dict_keys(['planner'])
2025-05-11 19:26:42,439 - DEBUG - Execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner']
2025-05-11 19:26:42,441 - DEBUG - planner response: {'error_type': 'NON_FATAL', 'error_message': 'OpenAI API key not found in config or environment variables', 'timestamp': '2025-05-11T19:26:42.241210', 'stack_trace': 'Traceback (most recent call last):\n  File "D:\\versa\\project_Files\\txtsql\\agents\\agents.py", line 886, in invoke\n    model = self.get_model(json_model=True)\n  File "D:\\versa\\project_Files\\txtsql\\agents\\agents.py", line 79, in get_model\n    return CustomOpenAIWrapper(model=self.model, temperature=self.temperature, response_format={"type": "json_object"})\n  File "D:\\versa\\project_Files\\txtsql\\models\\openai_models.py", line 65, in __init__\n    self.client = get_client()  # Get client when needed\n  File "D:\\versa\\project_Files\\txtsql\\models\\openai_models.py", line 25, in get_client\n    raise ValueError("OpenAI API key not found in config or environment variables")\nValueError: OpenAI API key not found in config or environment variables\n', 'component': 'PlannerAgent', 'state': {}, 'recommendations': ['Review error logs for more details', 'Check state values for inconsistencies', 'Contact support if issue persists']}
2025-05-11 19:26:42,447 - DEBUG - STDOUT: 
==== SELECTOR NODE START ====
2025-05-11 19:26:42,449 - DEBUG - STDOUT: Input state: user_question=list all the interfaces
2025-05-11 19:26:42,453 - DEBUG - STDOUT: Current execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner']
2025-05-11 19:26:42,455 - DEBUG - STDOUT: Planner response received: {
  "error_type": "NON_FATAL",
  "error_message": "OpenAI API key not found in config or environment variables",
  "timestamp": "2025-05-11T19:26:42.241210",
  "stack_trace": "Traceback (most recent call last):\n  File \"D:\\versa\\project_Files\\txtsql\\agents\\agents.py\", line 886, in invoke\n    model = self.get_model(json_model=True)\n  File \"D:\\versa\\project_Files\\txtsql\\agents\\agents.py\", line 79, in get_model\n    return CustomOpenAIWrapper(model=self.model, temperature=self.temperature, response_format={\"type\": \"json_object\"})\n  File \"D:\\versa\\project_Files\\txtsql\\models\\openai_models.py\", line 65, in __init__\n    self.client = get_client()  # Get client when needed\n  File \"D:\\versa\\project_Files\\txtsql\\models\\openai_models.py\", line 25, in get_client\n    raise ValueError(\"OpenAI API key not found in config or environment variables\")\nValueError: OpenAI API key not found in config or environment variables\n",
  "component": "PlannerAgent",
  "state": {},
  "recommendations": [
    "Review error logs for more details",
    "Check state values for inconsistencies",
    "Contact support if issue persists"
  ]
}
2025-05-11 19:26:42,474 - DEBUG - STDOUT: Selector is processing planner response for question: 'list all the interfaces'
2025-05-11 19:26:42,477 - DEBUG - STDOUT: NOTE: The selector node is currently simplified and doesn't use LLM.
2025-05-11 19:26:42,481 - DEBUG - STDOUT: It simply passes through to the SQLGenerator without making actual selections.
2025-05-11 19:26:42,483 - DEBUG - STDOUT: Selector node output: current_agent=SQLGenerator
2025-05-11 19:26:42,486 - DEBUG - STDOUT: Selector response being sent to SQLGenerator: {
  "raw": "Selection completed",
  "selected_schemas": {},
  "selected_tool": "sql_query",
  "selected_datasource": "information_schema.tables",
  "information_needed": "Table listing",
  "reason_for_selection": "Direct database query is the most efficient way to list tables",
  "query_parameters": {
    "columns": [
      "table_schema",
      "table_name"
    ],
    "filters": "table_type = 'BASE TABLE'"
  }
}
2025-05-11 19:26:42,495 - DEBUG - STDOUT: ==== SELECTOR NODE END ====
2025-05-11 19:26:42,498 - INFO - Processing agent: selector
2025-05-11 19:26:42,499 - DEBUG - Event type: <class 'langgraph.pregel.io.AddableUpdatesDict'>
2025-05-11 19:26:42,505 - DEBUG - Event keys: dict_keys(['selector'])
2025-05-11 19:26:42,506 - DEBUG - Execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector']
2025-05-11 19:26:42,509 - DEBUG - selector response: {'raw': 'Selection completed', 'selected_schemas': {}, 'selected_tool': 'sql_query', 'selected_datasource': 'information_schema.tables', 'information_needed': 'Table listing', 'reason_for_selection': 'Direct database query is the most efficient way to list tables', 'query_parameters': {'columns': ['table_schema', 'table_name'], 'filters': "table_type = 'BASE TABLE'"}}
2025-05-11 19:26:42,511 - DEBUG - STDOUT: 
==== SQL GENERATOR NODE START ====
2025-05-11 19:26:42,512 - DEBUG - STDOUT: Input state: user_question=list all the interfaces
2025-05-11 19:26:42,514 - DEBUG - STDOUT: Current execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector']
2025-05-11 19:26:42,515 - DEBUG - STDOUT: Selector response received: {
  "raw": "Selection completed",
  "selected_schemas": {},
  "selected_tool": "sql_query",
  "selected_datasource": "information_schema.tables",
  "information_needed": "Table listing",
  "reason_for_selection": "Direct database query is the most efficient way to list tables",
  "query_parameters": {
    "columns": [
      "table_schema",
      "table_name"
    ],
    "filters": "table_type = 'BASE TABLE'"
  }
}
2025-05-11 19:26:42,526 - DEBUG - STDOUT: Created SQLGenerator with model=chatgpt-4o-latest, server=openai
2025-05-11 19:26:42,529 - DEBUG - STDOUT: Invoking SQLGenerator with user_question: 'list all the interfaces'
2025-05-11 19:26:42,531 - DEBUG - STDOUT: SQLGenerator returned response: {
  "sql_generator_response": {
    "sql_query": "SELECT DISTINCT table_schema, table_name, column_name \n                FROM information_schema.columns \n                WHERE column_name ILIKE '%interface%'\n                AND table_schema NOT IN ('pg_catalog', 'information_schema')\n                ORDER BY table_schema, table_name;",
    "explanation": "Query to discover interface-related columns across all schemas",
    "validation_checks": [
      "Query syntax validated",
      "Schema and table specified",
      "Column list validated",
      "WHERE clause included",
      "Results limited for safety"
    ],
    "query_type": "interface_list",
    "estimated_complexity": "LOW",
    "required_indexes": [],
    "metadata": {
      "generated_at": "2025-05-11 19:26:42.530651",
      "validation_status": "valid",
      "has_limit": false,
      "has_order": true
    }
  }
}
2025-05-11 19:26:42,546 - DEBUG - STDOUT: SQL Generator node output: current_agent=reviewer
2025-05-11 19:26:42,550 - DEBUG - STDOUT: SQL query generated: SELECT DISTINCT table_schema, table_name, column_name 
                FROM information_schema.columns 
                WHERE column_name ILIKE '%interface%'
                AND table_schema NOT IN ('pg_catalog', 'information_schema')
                ORDER BY table_schema, table_name;
2025-05-11 19:26:42,563 - DEBUG - STDOUT: SQL Generator response being sent to reviewer: {
  "sql_generator_response": {
    "sql_query": "SELECT DISTINCT table_schema, table_name, column_name \n                FROM information_schema.columns \n                WHERE column_name ILIKE '%interface%'\n                AND table_schema NOT IN ('pg_catalog', 'information_schema')\n                ORDER BY table_schema, table_name;",
    "explanation": "Query to discover interface-related columns across all schemas",
    "validation_checks": [
      "Query syntax validated",
      "Schema and table specified",
      "Column list validated",
      "WHERE clause included",
      "Results limited for safety"
    ],
    "query_type": "interface_list",
    "estimated_complexity": "LOW",
    "required_indexes": [],
    "metadata": {
      "generated_at": "2025-05-11 19:26:42.530651",
      "validation_status": "valid",
      "has_limit": false,
      "has_order": true
    }
  }
}
2025-05-11 19:26:42,581 - DEBUG - STDOUT: ==== SQL GENERATOR NODE END ====
2025-05-11 19:26:42,591 - INFO - Processing agent: SQLGenerator
2025-05-11 19:26:42,595 - DEBUG - Event type: <class 'langgraph.pregel.io.AddableUpdatesDict'>
2025-05-11 19:26:42,597 - DEBUG - Event keys: dict_keys(['SQLGenerator'])
2025-05-11 19:26:42,598 - DEBUG - Execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator']
2025-05-11 19:26:42,601 - DEBUG - SQLGenerator response: {'sql_generator_response': {'sql_query': "SELECT DISTINCT table_schema, table_name, column_name \n                FROM information_schema.columns \n                WHERE column_name ILIKE '%interface%'\n                AND table_schema NOT IN ('pg_catalog', 'information_schema')\n                ORDER BY table_schema, table_name;", 'explanation': 'Query to discover interface-related columns across all schemas', 'validation_checks': ['Query syntax validated', 'Schema and table specified', 'Column list validated', 'WHERE clause included', 'Results limited for safety'], 'query_type': 'interface_list', 'estimated_complexity': 'LOW', 'required_indexes': [], 'metadata': {'generated_at': '2025-05-11 19:26:42.530651', 'validation_status': 'valid', 'has_limit': False, 'has_order': True}}}
2025-05-11 19:26:42,608 - DEBUG - STDOUT: 
==== REVIEWER NODE START ====
2025-05-11 19:26:42,609 - DEBUG - STDOUT: Input state: user_question=list all the interfaces
2025-05-11 19:26:42,611 - DEBUG - STDOUT: Current execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator']
2025-05-11 19:26:42,615 - DEBUG - STDOUT: SQL query to review: SELECT DISTINCT table_schema, table_name, column_name 
                FROM information_schema.columns 
                WHERE column_name ILIKE '%interface%'
                AND table_schema NOT IN ('pg_catalog', 'information_schema')
                ORDER BY table_schema, table_name;
2025-05-11 19:26:42,624 - DEBUG - STDOUT: SQLGenerator response received: {
  "sql_generator_response": {
    "sql_query": "SELECT DISTINCT table_schema, table_name, column_name \n                FROM information_schema.columns \n                WHERE column_name ILIKE '%interface%'\n                AND table_schema NOT IN ('pg_catalog', 'information_schema')\n                ORDER BY table_schema, table_name;",
    "explanation": "Query to discover interface-related columns across all schemas",
    "validation_checks": [
      "Query syntax validated",
      "Schema and table specified",
      "Column list validated",
      "WHERE clause included",
      "Results limited for safety"
    ],
    "query_type": "interface_list",
    "estimated_complexity": "LOW",
    "required_indexes": [],
    "metadata": {
      "generated_at": "2025-05-11 19:26:42.530651",
      "validation_status": "valid",
      "has_limit": false,
      "has_order": true
    }
  }
}
2025-05-11 19:26:42,640 - DEBUG - STDOUT: Reviewer is analyzing SQL query for question: 'list all the interfaces'
2025-05-11 19:26:42,644 - DEBUG - STDOUT: Using LLM-based ReviewerAgent to analyze the SQL query
2025-05-11 19:26:42,659 - DEBUG - STDOUT: Created ReviewerAgent with model=chatgpt-4o-latest, server=openai
2025-05-11 19:26:42,672 - DEBUG - STDOUT: Invoking ReviewerAgent with user_question: 'list all the interfaces' and sql_query: 'SELECT DISTINCT table_schema, table_name, column_name 
                FROM information_schema.columns 
                WHERE column_name ILIKE '%interface%'
                AND table_schema NOT IN ('pg_catalog', 'information_schema')
                ORDER BY table_schema, table_name;'
2025-05-11 19:26:42,679 - DEBUG - STDOUT: ReviewerAgent returned review: {
  "reviewer_response": {
    "is_correct": false,
    "issues": [
      "No LIMIT clause"
    ],
    "suggestions": [
      "Add LIMIT clause to prevent large result sets",
      "Ensure proper indexes exist for WHERE clause columns",
      "Consider adding indexes on WHERE clause columns",
      "Consider adding appropriate WHERE clauses",
      "Use explicit column names instead of *",
      "Add ORDER BY for consistent results"
    ],
    "explanation": "Query validation found issues: No LIMIT clause",
    "security_concerns": [],
    "performance_impact": "MEDIUM",
    "confidence_score": 1.0,
    "metadata": {
      "reviewed_at": "2025-05-11 19:26:42.679010",
      "query_type": "SELECT",
      "has_joins": false,
      "has_where": true,
      "has_limit": false
    }
  }
}
2025-05-11 19:26:42,694 - DEBUG - STDOUT: Reviewer node output: current_agent=sql_executor
2025-05-11 19:26:42,698 - DEBUG - STDOUT: Reviewer response being sent to sql_executor: {
  "reviewer_response": {
    "is_correct": false,
    "issues": [
      "No LIMIT clause"
    ],
    "suggestions": [
      "Add LIMIT clause to prevent large result sets",
      "Ensure proper indexes exist for WHERE clause columns",
      "Consider adding indexes on WHERE clause columns",
      "Consider adding appropriate WHERE clauses",
      "Use explicit column names instead of *",
      "Add ORDER BY for consistent results"
    ],
    "explanation": "Query validation found issues: No LIMIT clause",
    "security_concerns": [],
    "performance_impact": "MEDIUM",
    "confidence_score": 1.0,
    "metadata": {
      "reviewed_at": "2025-05-11 19:26:42.679010",
      "query_type": "SELECT",
      "has_joins": false,
      "has_where": true,
      "has_limit": false
    }
  }
}
2025-05-11 19:26:42,712 - DEBUG - STDOUT: ==== REVIEWER NODE END ====
2025-05-11 19:26:42,721 - INFO - Processing agent: reviewer
2025-05-11 19:26:42,723 - DEBUG - Event type: <class 'langgraph.pregel.io.AddableUpdatesDict'>
2025-05-11 19:26:42,725 - DEBUG - Event keys: dict_keys(['reviewer'])
2025-05-11 19:26:42,726 - DEBUG - Execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer']
2025-05-11 19:26:42,729 - DEBUG - reviewer response: {'reviewer_response': {'is_correct': False, 'issues': ['No LIMIT clause'], 'suggestions': ['Add LIMIT clause to prevent large result sets', 'Ensure proper indexes exist for WHERE clause columns', 'Consider adding indexes on WHERE clause columns', 'Consider adding appropriate WHERE clauses', 'Use explicit column names instead of *', 'Add ORDER BY for consistent results'], 'explanation': 'Query validation found issues: No LIMIT clause', 'security_concerns': [], 'performance_impact': 'MEDIUM', 'confidence_score': 1.0, 'metadata': {'reviewed_at': '2025-05-11 19:26:42.679010', 'query_type': 'SELECT', 'has_joins': False, 'has_where': True, 'has_limit': False}}}
2025-05-11 19:26:42,732 - DEBUG - STDOUT: 
==== SQL EXECUTOR NODE START ====
2025-05-11 19:26:42,742 - DEBUG - STDOUT: Input state: user_question=list all the interfaces
2025-05-11 19:26:42,746 - DEBUG - STDOUT: Current execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer']
2025-05-11 19:26:42,750 - DEBUG - STDOUT: SQL query to execute: SELECT DISTINCT table_schema, table_name, column_name 
                FROM information_schema.columns 
                WHERE column_name ILIKE '%interface%'
                AND table_schema NOT IN ('pg_catalog', 'information_schema')
                ORDER BY table_schema, table_name;
2025-05-11 19:26:42,765 - DEBUG - STDOUT: Reviewer response received: {
  "reviewer_response": {
    "is_correct": false,
    "issues": [
      "No LIMIT clause"
    ],
    "suggestions": [
      "Add LIMIT clause to prevent large result sets",
      "Ensure proper indexes exist for WHERE clause columns",
      "Consider adding indexes on WHERE clause columns",
      "Consider adding appropriate WHERE clauses",
      "Use explicit column names instead of *",
      "Add ORDER BY for consistent results"
    ],
    "explanation": "Query validation found issues: No LIMIT clause",
    "security_concerns": [],
    "performance_impact": "MEDIUM",
    "confidence_score": 1.0,
    "metadata": {
      "reviewed_at": "2025-05-11 19:26:42.679010",
      "query_type": "SELECT",
      "has_joins": false,
      "has_where": true,
      "has_limit": false
    }
  }
}
2025-05-11 19:26:42,780 - DEBUG - STDOUT: SQL Executor is processing SQL query: 'SELECT DISTINCT table_schema, table_name, column_name 
                FROM information_schema.columns 
                WHERE column_name ILIKE '%interface%'
                AND table_schema NOT IN ('pg_catalog', 'information_schema')
                ORDER BY table_schema, table_name;'
2025-05-11 19:26:42,788 - DEBUG - STDOUT: Executing SQL query against database: 'SELECT DISTINCT table_schema, table_name, column_name 
                FROM information_schema.columns 
                WHERE column_name ILIKE '%interface%'
                AND table_schema NOT IN ('pg_catalog', 'information_schema')
                ORDER BY table_schema, table_name;'
2025-05-11 19:26:42,791 - DEBUG - STDOUT: NOTE: SQL Executor does not use LLM. It directly executes the SQL query against the database.
2025-05-11 19:26:42,795 - DEBUG - STDOUT: Attempting database connection to localhost:5432/new as postgres
2025-05-11 19:26:42,872 - DEBUG - STDOUT: Successfully connected to database new at localhost:5432
2025-05-11 19:26:42,874 - DEBUG - STDOUT: Database is available
2025-05-11 19:26:42,876 - DEBUG - STDOUT: Attempting database connection to localhost:5432/new as postgres
2025-05-11 19:26:42,959 - DEBUG - STDOUT: Successfully connected to database new at localhost:5432
2025-05-11 19:26:43,001 - DEBUG - STDOUT: Successfully executed query against actual database
2025-05-11 19:26:43,001 - DEBUG - STDOUT: SQL query execution results: {
  "column_names": [
    "table_schema",
    "table_name",
    "column_name"
  ],
  "rows": [
    [
      "dev",
      "abap_integration_engine_interfaces",
      "abap_integration_engine_interface_destination"
    ],
    [
      "dev",
      "pro_agreements",
      "interface"
    ],
    [
      "dev",
      "pro_integrated_configuration_interfaces",
      "interface"
    ],
    [
      "dev",
      "pro_integrated_configuration_interfaces",
      "interface_namespace"
    ],
    [
      "dev",
      "pro_integrated_configuration_interfaces",
      "pro_integrated_configuration_interface_channel"
    ],
    [
      "dev",
      "pro_integrated_configuration_rules",
      "pro_integrated_configuration_interface_rules"
    ],
    [
      "dev",
      "pro_integrated_configurations",
      "interface"
    ],
    [
      "dev",
      "pro_performance_data",
      "interface_name"
    ],
    [
      "dev",
      "pro_performance_stats",
      "interface_name"
    ],
    [
      "dev",
      "system_mappings",
      "interface_pattern"
    ]
  ],
  "row_count": 10,
  "execution_time": 0.041693,
  "query": "SELECT DISTINCT table_schema, table_name, column_name \n                FROM information_schema.columns \n                WHERE column_name ILIKE '%interface%'\n                AND table_schema NOT IN ('pg_catalog', 'information_schema')\n                ORDER BY table_schema, table_name;",
  "status": "success"
}
2025-05-11 19:26:43,031 - DEBUG - STDOUT: SQL Executor node output: current_agent=router
2025-05-11 19:26:43,032 - DEBUG - STDOUT: SQL query results summary: status=success, rows=10
2025-05-11 19:26:43,034 - DEBUG - STDOUT: ==== SQL EXECUTOR NODE END ====
2025-05-11 19:26:43,035 - INFO - Processing agent: sql_executor
2025-05-11 19:26:43,040 - DEBUG - Event type: <class 'langgraph.pregel.io.AddableUpdatesDict'>
2025-05-11 19:26:43,041 - DEBUG - Event keys: dict_keys(['sql_executor'])
2025-05-11 19:26:43,042 - DEBUG - Execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor']
2025-05-11 19:26:43,044 - DEBUG - STDOUT: 
==== ROUTER NODE START ====
2025-05-11 19:26:43,046 - DEBUG - STDOUT: Input state: user_question=list all the interfaces
2025-05-11 19:26:43,048 - DEBUG - STDOUT: Current execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor']
2025-05-11 19:26:43,050 - DEBUG - STDOUT: RouterAgent returned decision: {
  "router_response": {
    "route_to": "planner",
    "reason": "Starting new workflow",
    "feedback": "Initializing workflow with planner",
    "state_updates": {
      "workflow_started": true,
      "start_time": "2025-05-11T19:26:43.050420"
    },
    "confidence_score": 1.0,
    "requires_human_input": false
  }
}
2025-05-11 19:26:43,052 - DEBUG - STDOUT: Route decision: planner
2025-05-11 19:26:43,052 - DEBUG - STDOUT: Router node output: current_agent=planner
2025-05-11 19:26:43,052 - DEBUG - STDOUT: Router response: {
  "route_to": "planner",
  "reason": "Starting new workflow",
  "feedback": "Initializing workflow with planner",
  "state_updates": {
    "workflow_started": true,
    "start_time": "2025-05-11T19:26:43.050420"
  },
  "confidence_score": 1.0,
  "requires_human_input": false
}
2025-05-11 19:26:43,065 - DEBUG - STDOUT: ==== ROUTER NODE END ====
2025-05-11 19:26:43,067 - DEBUG - STDOUT: ROUTE DECISION: planner -> to_planner
2025-05-11 19:26:43,069 - INFO - Processing agent: router
2025-05-11 19:26:43,069 - DEBUG - Event type: <class 'langgraph.pregel.io.AddableUpdatesDict'>
2025-05-11 19:26:43,069 - DEBUG - Event keys: dict_keys(['router'])
2025-05-11 19:26:43,069 - DEBUG - Execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router']
2025-05-11 19:26:43,069 - DEBUG - router response: {'route_to': 'planner', 'reason': 'Starting new workflow', 'feedback': 'Initializing workflow with planner', 'state_updates': {'workflow_started': True, 'start_time': '2025-05-11T19:26:43.050420'}, 'confidence_score': 1.0, 'requires_human_input': False}
2025-05-11 19:26:43,069 - DEBUG - STDOUT: 
==== PLANNER NODE START ====
2025-05-11 19:26:43,080 - DEBUG - STDOUT: Input state: user_question=list all the interfaces
2025-05-11 19:26:43,082 - DEBUG - STDOUT: Current execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router']
2025-05-11 19:26:43,085 - DEBUG - STDOUT: Processing user question: 'list all the interfaces'
2025-05-11 19:26:43,087 - DEBUG - STDOUT: Error initializing database services: name 'DatabaseMetadataStore' is not defined
2025-05-11 19:26:43,203 - DEBUG - STDERR: Traceback (most recent call last):
2025-05-11 19:26:43,205 - DEBUG - STDERR:   File "D:\versa\project_Files\txtsql\agents\agents.py", line 394, in __init__
    self.metadata_store = DatabaseMetadataStore()
2025-05-11 19:26:43,207 - DEBUG - STDERR: NameError: name 'DatabaseMetadataStore' is not defined
2025-05-11 19:26:43,210 - DEBUG - STDOUT: Successfully initialized PlannerAgent with database capabilities using model=chatgpt-4o-latest, server=openai
2025-05-11 19:26:43,213 - DEBUG - STDOUT: PlannerAgent is using LLM to analyze the query and determine the appropriate database tables and columns
2025-05-11 19:26:43,220 - DEBUG - STDOUT: Invoking PlannerAgent with question: 'list all the interfaces'
2025-05-11 19:26:43,232 - DEBUG - STDOUT: Error in PlannerAgent.invoke: OpenAI API key not found in config or environment variables
2025-05-11 19:26:43,386 - DEBUG - STDERR: Traceback (most recent call last):
2025-05-11 19:26:43,388 - DEBUG - STDERR:   File "D:\versa\project_Files\txtsql\agents\agents.py", line 886, in invoke
    model = self.get_model(json_model=True)
2025-05-11 19:26:43,389 - DEBUG - STDERR:   File "D:\versa\project_Files\txtsql\agents\agents.py", line 79, in get_model
    return CustomOpenAIWrapper(model=self.model, temperature=self.temperature, response_format={"type": "json_object"})
2025-05-11 19:26:43,392 - DEBUG - STDERR:   File "D:\versa\project_Files\txtsql\models\openai_models.py", line 65, in __init__
    self.client = get_client()  # Get client when needed
2025-05-11 19:26:43,395 - DEBUG - STDERR:   File "D:\versa\project_Files\txtsql\models\openai_models.py", line 25, in get_client
    raise ValueError("OpenAI API key not found in config or environment variables")
2025-05-11 19:26:43,399 - DEBUG - STDERR: ValueError: OpenAI API key not found in config or environment variables
2025-05-11 19:26:43,553 - DEBUG - STDOUT: PlannerAgent returned plan: {
  "error_type": "NON_FATAL",
  "error_message": "OpenAI API key not found in config or environment variables",
  "timestamp": "2025-05-11T19:26:43.401751",
  "stack_trace": "Traceback (most recent call last):\n  File \"D:\\versa\\project_Files\\txtsql\\agents\\agents.py\", line 886, in invoke\n    model = self.get_model(json_model=True)\n  File \"D:\\versa\\project_Files\\txtsql\\agents\\agents.py\", line 79, in get_model\n    return CustomOpenAIWrapper(model=self.model, temperature=self.temperature, response_format={\"type\": \"json_object\"})\n  File \"D:\\versa\\project_Files\\txtsql\\models\\openai_models.py\", line 65, in __init__\n    self.client = get_client()  # Get client when needed\n  File \"D:\\versa\\project_Files\\txtsql\\models\\openai_models.py\", line 25, in get_client\n    raise ValueError(\"OpenAI API key not found in config or environment variables\")\nValueError: OpenAI API key not found in config or environment variables\n",
  "component": "PlannerAgent",
  "state": {},
  "recommendations": [
    "Review error logs for more details",
    "Check state values for inconsistencies",
    "Contact support if issue persists"
  ]
}
2025-05-11 19:26:43,562 - DEBUG - STDOUT: Planner node output: current_agent=selector
2025-05-11 19:26:43,563 - DEBUG - STDOUT: Planner response being sent to selector: {
  "error_type": "NON_FATAL",
  "error_message": "OpenAI API key not found in config or environment variables",
  "timestamp": "2025-05-11T19:26:43.401751",
  "stack_trace": "Traceback (most recent call last):\n  File \"D:\\versa\\project_Files\\txtsql\\agents\\agents.py\", line 886, in invoke\n    model = self.get_model(json_model=True)\n  File \"D:\\versa\\project_Files\\txtsql\\agents\\agents.py\", line 79, in get_model\n    return CustomOpenAIWrapper(model=self.model, temperature=self.temperature, response_format={\"type\": \"json_object\"})\n  File \"D:\\versa\\project_Files\\txtsql\\models\\openai_models.py\", line 65, in __init__\n    self.client = get_client()  # Get client when needed\n  File \"D:\\versa\\project_Files\\txtsql\\models\\openai_models.py\", line 25, in get_client\n    raise ValueError(\"OpenAI API key not found in config or environment variables\")\nValueError: OpenAI API key not found in config or environment variables\n",
  "component": "PlannerAgent",
  "state": {},
  "recommendations": [
    "Review error logs for more details",
    "Check state values for inconsistencies",
    "Contact support if issue persists"
  ]
}
2025-05-11 19:26:43,572 - DEBUG - STDOUT: ==== PLANNER NODE END ====
2025-05-11 19:26:43,575 - INFO - Processing agent: planner
2025-05-11 19:26:43,578 - DEBUG - Event type: <class 'langgraph.pregel.io.AddableUpdatesDict'>
2025-05-11 19:26:43,580 - DEBUG - Event keys: dict_keys(['planner'])
2025-05-11 19:26:43,581 - DEBUG - Execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner']
2025-05-11 19:26:43,585 - DEBUG - planner response: {'error_type': 'NON_FATAL', 'error_message': 'OpenAI API key not found in config or environment variables', 'timestamp': '2025-05-11T19:26:43.401751', 'stack_trace': 'Traceback (most recent call last):\n  File "D:\\versa\\project_Files\\txtsql\\agents\\agents.py", line 886, in invoke\n    model = self.get_model(json_model=True)\n  File "D:\\versa\\project_Files\\txtsql\\agents\\agents.py", line 79, in get_model\n    return CustomOpenAIWrapper(model=self.model, temperature=self.temperature, response_format={"type": "json_object"})\n  File "D:\\versa\\project_Files\\txtsql\\models\\openai_models.py", line 65, in __init__\n    self.client = get_client()  # Get client when needed\n  File "D:\\versa\\project_Files\\txtsql\\models\\openai_models.py", line 25, in get_client\n    raise ValueError("OpenAI API key not found in config or environment variables")\nValueError: OpenAI API key not found in config or environment variables\n', 'component': 'PlannerAgent', 'state': {}, 'recommendations': ['Review error logs for more details', 'Check state values for inconsistencies', 'Contact support if issue persists']}
2025-05-11 19:26:43,590 - DEBUG - STDOUT: 
==== SELECTOR NODE START ====
2025-05-11 19:26:43,592 - DEBUG - STDOUT: Input state: user_question=list all the interfaces
2025-05-11 19:26:43,594 - DEBUG - STDOUT: Current execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner']
2025-05-11 19:26:43,597 - DEBUG - STDOUT: Planner response received: {
  "error_type": "NON_FATAL",
  "error_message": "OpenAI API key not found in config or environment variables",
  "timestamp": "2025-05-11T19:26:43.401751",
  "stack_trace": "Traceback (most recent call last):\n  File \"D:\\versa\\project_Files\\txtsql\\agents\\agents.py\", line 886, in invoke\n    model = self.get_model(json_model=True)\n  File \"D:\\versa\\project_Files\\txtsql\\agents\\agents.py\", line 79, in get_model\n    return CustomOpenAIWrapper(model=self.model, temperature=self.temperature, response_format={\"type\": \"json_object\"})\n  File \"D:\\versa\\project_Files\\txtsql\\models\\openai_models.py\", line 65, in __init__\n    self.client = get_client()  # Get client when needed\n  File \"D:\\versa\\project_Files\\txtsql\\models\\openai_models.py\", line 25, in get_client\n    raise ValueError(\"OpenAI API key not found in config or environment variables\")\nValueError: OpenAI API key not found in config or environment variables\n",
  "component": "PlannerAgent",
  "state": {},
  "recommendations": [
    "Review error logs for more details",
    "Check state values for inconsistencies",
    "Contact support if issue persists"
  ]
}
2025-05-11 19:26:43,608 - DEBUG - STDOUT: Selector is processing planner response for question: 'list all the interfaces'
2025-05-11 19:26:43,611 - DEBUG - STDOUT: NOTE: The selector node is currently simplified and doesn't use LLM.
2025-05-11 19:26:43,613 - DEBUG - STDOUT: It simply passes through to the SQLGenerator without making actual selections.
2025-05-11 19:26:43,615 - DEBUG - STDOUT: Selector node output: current_agent=SQLGenerator
2025-05-11 19:26:43,616 - DEBUG - STDOUT: Selector response being sent to SQLGenerator: {
  "raw": "Selection completed",
  "selected_schemas": {},
  "selected_tool": "sql_query",
  "selected_datasource": "information_schema.tables",
  "information_needed": "Table listing",
  "reason_for_selection": "Direct database query is the most efficient way to list tables",
  "query_parameters": {
    "columns": [
      "table_schema",
      "table_name"
    ],
    "filters": "table_type = 'BASE TABLE'"
  }
}
2025-05-11 19:26:43,627 - DEBUG - STDOUT: ==== SELECTOR NODE END ====
2025-05-11 19:26:43,630 - INFO - Processing agent: selector
2025-05-11 19:26:43,633 - DEBUG - Event type: <class 'langgraph.pregel.io.AddableUpdatesDict'>
2025-05-11 19:26:43,636 - DEBUG - Event keys: dict_keys(['selector'])
2025-05-11 19:26:43,639 - DEBUG - Execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector']
2025-05-11 19:26:43,641 - DEBUG - selector response: {'raw': 'Selection completed', 'selected_schemas': {}, 'selected_tool': 'sql_query', 'selected_datasource': 'information_schema.tables', 'information_needed': 'Table listing', 'reason_for_selection': 'Direct database query is the most efficient way to list tables', 'query_parameters': {'columns': ['table_schema', 'table_name'], 'filters': "table_type = 'BASE TABLE'"}}
2025-05-11 19:26:43,642 - DEBUG - STDOUT: 
==== SQL GENERATOR NODE START ====
2025-05-11 19:26:43,644 - DEBUG - STDOUT: Input state: user_question=list all the interfaces
2025-05-11 19:26:43,647 - DEBUG - STDOUT: Current execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector']
2025-05-11 19:26:43,649 - DEBUG - STDOUT: Selector response received: {
  "raw": "Selection completed",
  "selected_schemas": {},
  "selected_tool": "sql_query",
  "selected_datasource": "information_schema.tables",
  "information_needed": "Table listing",
  "reason_for_selection": "Direct database query is the most efficient way to list tables",
  "query_parameters": {
    "columns": [
      "table_schema",
      "table_name"
    ],
    "filters": "table_type = 'BASE TABLE'"
  }
}
2025-05-11 19:26:43,657 - DEBUG - STDOUT: Created SQLGenerator with model=chatgpt-4o-latest, server=openai
2025-05-11 19:26:43,658 - DEBUG - STDOUT: Invoking SQLGenerator with user_question: 'list all the interfaces'
2025-05-11 19:26:43,664 - DEBUG - STDOUT: SQLGenerator returned response: {
  "sql_generator_response": {
    "sql_query": "SELECT DISTINCT table_schema, table_name, column_name \n                FROM information_schema.columns \n                WHERE column_name ILIKE '%interface%'\n                AND table_schema NOT IN ('pg_catalog', 'information_schema')\n                ORDER BY table_schema, table_name;",
    "explanation": "Query to discover interface-related columns across all schemas",
    "validation_checks": [
      "Query syntax validated",
      "Schema and table specified",
      "Column list validated",
      "WHERE clause included",
      "Results limited for safety"
    ],
    "query_type": "interface_list",
    "estimated_complexity": "LOW",
    "required_indexes": [],
    "metadata": {
      "generated_at": "2025-05-11 19:26:43.663401",
      "validation_status": "valid",
      "has_limit": false,
      "has_order": true
    }
  }
}
2025-05-11 19:26:43,677 - DEBUG - STDOUT: SQL Generator node output: current_agent=reviewer
2025-05-11 19:26:43,677 - DEBUG - STDOUT: SQL query generated: SELECT DISTINCT table_schema, table_name, column_name 
                FROM information_schema.columns 
                WHERE column_name ILIKE '%interface%'
                AND table_schema NOT IN ('pg_catalog', 'information_schema')
                ORDER BY table_schema, table_name;
2025-05-11 19:26:43,682 - DEBUG - STDOUT: SQL Generator response being sent to reviewer: {
  "sql_generator_response": {
    "sql_query": "SELECT DISTINCT table_schema, table_name, column_name \n                FROM information_schema.columns \n                WHERE column_name ILIKE '%interface%'\n                AND table_schema NOT IN ('pg_catalog', 'information_schema')\n                ORDER BY table_schema, table_name;",
    "explanation": "Query to discover interface-related columns across all schemas",
    "validation_checks": [
      "Query syntax validated",
      "Schema and table specified",
      "Column list validated",
      "WHERE clause included",
      "Results limited for safety"
    ],
    "query_type": "interface_list",
    "estimated_complexity": "LOW",
    "required_indexes": [],
    "metadata": {
      "generated_at": "2025-05-11 19:26:43.663401",
      "validation_status": "valid",
      "has_limit": false,
      "has_order": true
    }
  }
}
2025-05-11 19:26:43,696 - DEBUG - STDOUT: ==== SQL GENERATOR NODE END ====
2025-05-11 19:26:43,699 - INFO - Processing agent: SQLGenerator
2025-05-11 19:26:43,702 - DEBUG - Event type: <class 'langgraph.pregel.io.AddableUpdatesDict'>
2025-05-11 19:26:43,703 - DEBUG - Event keys: dict_keys(['SQLGenerator'])
2025-05-11 19:26:43,704 - DEBUG - Execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator']
2025-05-11 19:26:43,705 - DEBUG - SQLGenerator response: {'sql_generator_response': {'sql_query': "SELECT DISTINCT table_schema, table_name, column_name \n                FROM information_schema.columns \n                WHERE column_name ILIKE '%interface%'\n                AND table_schema NOT IN ('pg_catalog', 'information_schema')\n                ORDER BY table_schema, table_name;", 'explanation': 'Query to discover interface-related columns across all schemas', 'validation_checks': ['Query syntax validated', 'Schema and table specified', 'Column list validated', 'WHERE clause included', 'Results limited for safety'], 'query_type': 'interface_list', 'estimated_complexity': 'LOW', 'required_indexes': [], 'metadata': {'generated_at': '2025-05-11 19:26:43.663401', 'validation_status': 'valid', 'has_limit': False, 'has_order': True}}}
2025-05-11 19:26:43,709 - DEBUG - STDOUT: 
==== REVIEWER NODE START ====
2025-05-11 19:26:43,713 - DEBUG - STDOUT: Input state: user_question=list all the interfaces
2025-05-11 19:26:43,715 - DEBUG - STDOUT: Current execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator']
2025-05-11 19:26:43,718 - DEBUG - STDOUT: SQL query to review: SELECT DISTINCT table_schema, table_name, column_name 
                FROM information_schema.columns 
                WHERE column_name ILIKE '%interface%'
                AND table_schema NOT IN ('pg_catalog', 'information_schema')
                ORDER BY table_schema, table_name;
2025-05-11 19:26:43,724 - DEBUG - STDOUT: SQLGenerator response received: {
  "sql_generator_response": {
    "sql_query": "SELECT DISTINCT table_schema, table_name, column_name \n                FROM information_schema.columns \n                WHERE column_name ILIKE '%interface%'\n                AND table_schema NOT IN ('pg_catalog', 'information_schema')\n                ORDER BY table_schema, table_name;",
    "explanation": "Query to discover interface-related columns across all schemas",
    "validation_checks": [
      "Query syntax validated",
      "Schema and table specified",
      "Column list validated",
      "WHERE clause included",
      "Results limited for safety"
    ],
    "query_type": "interface_list",
    "estimated_complexity": "LOW",
    "required_indexes": [],
    "metadata": {
      "generated_at": "2025-05-11 19:26:43.663401",
      "validation_status": "valid",
      "has_limit": false,
      "has_order": true
    }
  }
}
2025-05-11 19:26:43,735 - DEBUG - STDOUT: Reviewer is analyzing SQL query for question: 'list all the interfaces'
2025-05-11 19:26:43,738 - DEBUG - STDOUT: Using LLM-based ReviewerAgent to analyze the SQL query
2025-05-11 19:26:43,740 - DEBUG - STDOUT: Created ReviewerAgent with model=chatgpt-4o-latest, server=openai
2025-05-11 19:26:43,742 - DEBUG - STDOUT: Invoking ReviewerAgent with user_question: 'list all the interfaces' and sql_query: 'SELECT DISTINCT table_schema, table_name, column_name 
                FROM information_schema.columns 
                WHERE column_name ILIKE '%interface%'
                AND table_schema NOT IN ('pg_catalog', 'information_schema')
                ORDER BY table_schema, table_name;'
2025-05-11 19:26:43,748 - DEBUG - STDOUT: ReviewerAgent returned review: {
  "reviewer_response": {
    "is_correct": false,
    "issues": [
      "No LIMIT clause"
    ],
    "suggestions": [
      "Add LIMIT clause to prevent large result sets",
      "Ensure proper indexes exist for WHERE clause columns",
      "Consider adding indexes on WHERE clause columns",
      "Consider adding appropriate WHERE clauses",
      "Use explicit column names instead of *",
      "Add ORDER BY for consistent results"
    ],
    "explanation": "Query validation found issues: No LIMIT clause",
    "security_concerns": [],
    "performance_impact": "MEDIUM",
    "confidence_score": 1.0,
    "metadata": {
      "reviewed_at": "2025-05-11 19:26:43.747536",
      "query_type": "SELECT",
      "has_joins": false,
      "has_where": true,
      "has_limit": false
    }
  }
}
2025-05-11 19:26:43,758 - DEBUG - STDOUT: Reviewer node output: current_agent=sql_executor
2025-05-11 19:26:43,760 - DEBUG - STDOUT: Reviewer response being sent to sql_executor: {
  "reviewer_response": {
    "is_correct": false,
    "issues": [
      "No LIMIT clause"
    ],
    "suggestions": [
      "Add LIMIT clause to prevent large result sets",
      "Ensure proper indexes exist for WHERE clause columns",
      "Consider adding indexes on WHERE clause columns",
      "Consider adding appropriate WHERE clauses",
      "Use explicit column names instead of *",
      "Add ORDER BY for consistent results"
    ],
    "explanation": "Query validation found issues: No LIMIT clause",
    "security_concerns": [],
    "performance_impact": "MEDIUM",
    "confidence_score": 1.0,
    "metadata": {
      "reviewed_at": "2025-05-11 19:26:43.747536",
      "query_type": "SELECT",
      "has_joins": false,
      "has_where": true,
      "has_limit": false
    }
  }
}
2025-05-11 19:26:43,772 - DEBUG - STDOUT: ==== REVIEWER NODE END ====
2025-05-11 19:26:43,776 - INFO - Processing agent: reviewer
2025-05-11 19:26:43,778 - DEBUG - Event type: <class 'langgraph.pregel.io.AddableUpdatesDict'>
2025-05-11 19:26:43,780 - DEBUG - Event keys: dict_keys(['reviewer'])
2025-05-11 19:26:43,781 - DEBUG - Execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer']
2025-05-11 19:26:43,783 - DEBUG - reviewer response: {'reviewer_response': {'is_correct': False, 'issues': ['No LIMIT clause'], 'suggestions': ['Add LIMIT clause to prevent large result sets', 'Ensure proper indexes exist for WHERE clause columns', 'Consider adding indexes on WHERE clause columns', 'Consider adding appropriate WHERE clauses', 'Use explicit column names instead of *', 'Add ORDER BY for consistent results'], 'explanation': 'Query validation found issues: No LIMIT clause', 'security_concerns': [], 'performance_impact': 'MEDIUM', 'confidence_score': 1.0, 'metadata': {'reviewed_at': '2025-05-11 19:26:43.747536', 'query_type': 'SELECT', 'has_joins': False, 'has_where': True, 'has_limit': False}}}
2025-05-11 19:26:43,786 - DEBUG - STDOUT: 
==== SQL EXECUTOR NODE START ====
2025-05-11 19:26:43,788 - DEBUG - STDOUT: Input state: user_question=list all the interfaces
2025-05-11 19:26:43,790 - DEBUG - STDOUT: Current execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer']
2025-05-11 19:26:43,794 - DEBUG - STDOUT: SQL query to execute: SELECT DISTINCT table_schema, table_name, column_name 
                FROM information_schema.columns 
                WHERE column_name ILIKE '%interface%'
                AND table_schema NOT IN ('pg_catalog', 'information_schema')
                ORDER BY table_schema, table_name;
2025-05-11 19:26:43,799 - DEBUG - STDOUT: Reviewer response received: {
  "reviewer_response": {
    "is_correct": false,
    "issues": [
      "No LIMIT clause"
    ],
    "suggestions": [
      "Add LIMIT clause to prevent large result sets",
      "Ensure proper indexes exist for WHERE clause columns",
      "Consider adding indexes on WHERE clause columns",
      "Consider adding appropriate WHERE clauses",
      "Use explicit column names instead of *",
      "Add ORDER BY for consistent results"
    ],
    "explanation": "Query validation found issues: No LIMIT clause",
    "security_concerns": [],
    "performance_impact": "MEDIUM",
    "confidence_score": 1.0,
    "metadata": {
      "reviewed_at": "2025-05-11 19:26:43.747536",
      "query_type": "SELECT",
      "has_joins": false,
      "has_where": true,
      "has_limit": false
    }
  }
}
2025-05-11 19:26:43,810 - DEBUG - STDOUT: SQL Executor is processing SQL query: 'SELECT DISTINCT table_schema, table_name, column_name 
                FROM information_schema.columns 
                WHERE column_name ILIKE '%interface%'
                AND table_schema NOT IN ('pg_catalog', 'information_schema')
                ORDER BY table_schema, table_name;'
2025-05-11 19:26:43,814 - DEBUG - STDOUT: Executing SQL query against database: 'SELECT DISTINCT table_schema, table_name, column_name 
                FROM information_schema.columns 
                WHERE column_name ILIKE '%interface%'
                AND table_schema NOT IN ('pg_catalog', 'information_schema')
                ORDER BY table_schema, table_name;'
2025-05-11 19:26:43,819 - DEBUG - STDOUT: NOTE: SQL Executor does not use LLM. It directly executes the SQL query against the database.
2025-05-11 19:26:43,821 - DEBUG - STDOUT: Attempting database connection to localhost:5432/new as postgres
2025-05-11 19:26:43,898 - DEBUG - STDOUT: Successfully connected to database new at localhost:5432
2025-05-11 19:26:43,902 - DEBUG - STDOUT: Database is available
2025-05-11 19:26:43,904 - DEBUG - STDOUT: Attempting database connection to localhost:5432/new as postgres
2025-05-11 19:26:43,978 - DEBUG - STDOUT: Successfully connected to database new at localhost:5432
2025-05-11 19:26:44,006 - DEBUG - STDOUT: Successfully executed query against actual database
2025-05-11 19:26:44,007 - DEBUG - STDOUT: SQL query execution results: {
  "column_names": [
    "table_schema",
    "table_name",
    "column_name"
  ],
  "rows": [
    [
      "dev",
      "abap_integration_engine_interfaces",
      "abap_integration_engine_interface_destination"
    ],
    [
      "dev",
      "pro_agreements",
      "interface"
    ],
    [
      "dev",
      "pro_integrated_configuration_interfaces",
      "interface"
    ],
    [
      "dev",
      "pro_integrated_configuration_interfaces",
      "interface_namespace"
    ],
    [
      "dev",
      "pro_integrated_configuration_interfaces",
      "pro_integrated_configuration_interface_channel"
    ],
    [
      "dev",
      "pro_integrated_configuration_rules",
      "pro_integrated_configuration_interface_rules"
    ],
    [
      "dev",
      "pro_integrated_configurations",
      "interface"
    ],
    [
      "dev",
      "pro_performance_data",
      "interface_name"
    ],
    [
      "dev",
      "pro_performance_stats",
      "interface_name"
    ],
    [
      "dev",
      "system_mappings",
      "interface_pattern"
    ]
  ],
  "row_count": 10,
  "execution_time": 0.026901,
  "query": "SELECT DISTINCT table_schema, table_name, column_name \n                FROM information_schema.columns \n                WHERE column_name ILIKE '%interface%'\n                AND table_schema NOT IN ('pg_catalog', 'information_schema')\n                ORDER BY table_schema, table_name;",
  "status": "success"
}
2025-05-11 19:26:44,030 - DEBUG - STDOUT: SQL Executor node output: current_agent=router
2025-05-11 19:26:44,031 - DEBUG - STDOUT: SQL query results summary: status=success, rows=10
2025-05-11 19:26:44,032 - DEBUG - STDOUT: ==== SQL EXECUTOR NODE END ====
2025-05-11 19:26:44,035 - INFO - Processing agent: sql_executor
2025-05-11 19:26:44,036 - DEBUG - Event type: <class 'langgraph.pregel.io.AddableUpdatesDict'>
2025-05-11 19:26:44,038 - DEBUG - Event keys: dict_keys(['sql_executor'])
2025-05-11 19:26:44,039 - DEBUG - Execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor']
2025-05-11 19:26:44,040 - DEBUG - STDOUT: 
==== ROUTER NODE START ====
2025-05-11 19:26:44,041 - DEBUG - STDOUT: Input state: user_question=list all the interfaces
2025-05-11 19:26:44,044 - DEBUG - STDOUT: Current execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor']
2025-05-11 19:26:44,047 - DEBUG - STDOUT: RouterAgent returned decision: {
  "router_response": {
    "route_to": "planner",
    "reason": "Starting new workflow",
    "feedback": "Initializing workflow with planner",
    "state_updates": {
      "workflow_started": true,
      "start_time": "2025-05-11T19:26:44.047160"
    },
    "confidence_score": 1.0,
    "requires_human_input": false
  }
}
2025-05-11 19:26:44,053 - DEBUG - STDOUT: Route decision: planner
2025-05-11 19:26:44,055 - DEBUG - STDOUT: Router node output: current_agent=planner
2025-05-11 19:26:44,057 - DEBUG - STDOUT: Router response: {
  "route_to": "planner",
  "reason": "Starting new workflow",
  "feedback": "Initializing workflow with planner",
  "state_updates": {
    "workflow_started": true,
    "start_time": "2025-05-11T19:26:44.047160"
  },
  "confidence_score": 1.0,
  "requires_human_input": false
}
2025-05-11 19:26:44,061 - DEBUG - STDOUT: ==== ROUTER NODE END ====
2025-05-11 19:26:44,062 - DEBUG - STDOUT: ROUTE DECISION: planner -> to_planner
2025-05-11 19:26:44,065 - INFO - Processing agent: router
2025-05-11 19:26:44,066 - DEBUG - Event type: <class 'langgraph.pregel.io.AddableUpdatesDict'>
2025-05-11 19:26:44,067 - DEBUG - Event keys: dict_keys(['router'])
2025-05-11 19:26:44,068 - DEBUG - Execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router']
2025-05-11 19:26:44,070 - DEBUG - router response: {'route_to': 'planner', 'reason': 'Starting new workflow', 'feedback': 'Initializing workflow with planner', 'state_updates': {'workflow_started': True, 'start_time': '2025-05-11T19:26:44.047160'}, 'confidence_score': 1.0, 'requires_human_input': False}
2025-05-11 19:26:44,073 - DEBUG - STDOUT: 
==== PLANNER NODE START ====
2025-05-11 19:26:44,074 - DEBUG - STDOUT: Input state: user_question=list all the interfaces
2025-05-11 19:26:44,075 - DEBUG - STDOUT: Current execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router']
2025-05-11 19:26:44,078 - DEBUG - STDOUT: Processing user question: 'list all the interfaces'
2025-05-11 19:26:44,079 - DEBUG - STDOUT: Error initializing database services: name 'DatabaseMetadataStore' is not defined
2025-05-11 19:26:44,169 - DEBUG - STDERR: Traceback (most recent call last):
2025-05-11 19:26:44,170 - DEBUG - STDERR:   File "D:\versa\project_Files\txtsql\agents\agents.py", line 394, in __init__
    self.metadata_store = DatabaseMetadataStore()
2025-05-11 19:26:44,173 - DEBUG - STDERR: NameError: name 'DatabaseMetadataStore' is not defined
2025-05-11 19:26:44,176 - DEBUG - STDOUT: Successfully initialized PlannerAgent with database capabilities using model=chatgpt-4o-latest, server=openai
2025-05-11 19:26:44,178 - DEBUG - STDOUT: PlannerAgent is using LLM to analyze the query and determine the appropriate database tables and columns
2025-05-11 19:26:44,179 - DEBUG - STDOUT: Invoking PlannerAgent with question: 'list all the interfaces'
2025-05-11 19:26:44,182 - DEBUG - STDOUT: Error in PlannerAgent.invoke: OpenAI API key not found in config or environment variables
2025-05-11 19:26:44,334 - DEBUG - STDERR: Traceback (most recent call last):
2025-05-11 19:26:44,336 - DEBUG - STDERR:   File "D:\versa\project_Files\txtsql\agents\agents.py", line 886, in invoke
    model = self.get_model(json_model=True)
2025-05-11 19:26:44,338 - DEBUG - STDERR:   File "D:\versa\project_Files\txtsql\agents\agents.py", line 79, in get_model
    return CustomOpenAIWrapper(model=self.model, temperature=self.temperature, response_format={"type": "json_object"})
2025-05-11 19:26:44,340 - DEBUG - STDERR:   File "D:\versa\project_Files\txtsql\models\openai_models.py", line 65, in __init__
    self.client = get_client()  # Get client when needed
2025-05-11 19:26:44,343 - DEBUG - STDERR:   File "D:\versa\project_Files\txtsql\models\openai_models.py", line 25, in get_client
    raise ValueError("OpenAI API key not found in config or environment variables")
2025-05-11 19:26:44,346 - DEBUG - STDERR: ValueError: OpenAI API key not found in config or environment variables
2025-05-11 19:26:44,484 - DEBUG - STDOUT: PlannerAgent returned plan: {
  "error_type": "NON_FATAL",
  "error_message": "OpenAI API key not found in config or environment variables",
  "timestamp": "2025-05-11T19:26:44.348504",
  "stack_trace": "Traceback (most recent call last):\n  File \"D:\\versa\\project_Files\\txtsql\\agents\\agents.py\", line 886, in invoke\n    model = self.get_model(json_model=True)\n  File \"D:\\versa\\project_Files\\txtsql\\agents\\agents.py\", line 79, in get_model\n    return CustomOpenAIWrapper(model=self.model, temperature=self.temperature, response_format={\"type\": \"json_object\"})\n  File \"D:\\versa\\project_Files\\txtsql\\models\\openai_models.py\", line 65, in __init__\n    self.client = get_client()  # Get client when needed\n  File \"D:\\versa\\project_Files\\txtsql\\models\\openai_models.py\", line 25, in get_client\n    raise ValueError(\"OpenAI API key not found in config or environment variables\")\nValueError: OpenAI API key not found in config or environment variables\n",
  "component": "PlannerAgent",
  "state": {},
  "recommendations": [
    "Review error logs for more details",
    "Check state values for inconsistencies",
    "Contact support if issue persists"
  ]
}
2025-05-11 19:26:44,499 - DEBUG - STDOUT: Planner node output: current_agent=selector
2025-05-11 19:26:44,504 - DEBUG - STDOUT: Planner response being sent to selector: {
  "error_type": "NON_FATAL",
  "error_message": "OpenAI API key not found in config or environment variables",
  "timestamp": "2025-05-11T19:26:44.348504",
  "stack_trace": "Traceback (most recent call last):\n  File \"D:\\versa\\project_Files\\txtsql\\agents\\agents.py\", line 886, in invoke\n    model = self.get_model(json_model=True)\n  File \"D:\\versa\\project_Files\\txtsql\\agents\\agents.py\", line 79, in get_model\n    return CustomOpenAIWrapper(model=self.model, temperature=self.temperature, response_format={\"type\": \"json_object\"})\n  File \"D:\\versa\\project_Files\\txtsql\\models\\openai_models.py\", line 65, in __init__\n    self.client = get_client()  # Get client when needed\n  File \"D:\\versa\\project_Files\\txtsql\\models\\openai_models.py\", line 25, in get_client\n    raise ValueError(\"OpenAI API key not found in config or environment variables\")\nValueError: OpenAI API key not found in config or environment variables\n",
  "component": "PlannerAgent",
  "state": {},
  "recommendations": [
    "Review error logs for more details",
    "Check state values for inconsistencies",
    "Contact support if issue persists"
  ]
}
2025-05-11 19:26:44,514 - DEBUG - STDOUT: ==== PLANNER NODE END ====
2025-05-11 19:26:44,517 - INFO - Processing agent: planner
2025-05-11 19:26:44,519 - DEBUG - Event type: <class 'langgraph.pregel.io.AddableUpdatesDict'>
2025-05-11 19:26:44,522 - DEBUG - Event keys: dict_keys(['planner'])
2025-05-11 19:26:44,523 - DEBUG - Execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner']
2025-05-11 19:26:44,525 - DEBUG - planner response: {'error_type': 'NON_FATAL', 'error_message': 'OpenAI API key not found in config or environment variables', 'timestamp': '2025-05-11T19:26:44.348504', 'stack_trace': 'Traceback (most recent call last):\n  File "D:\\versa\\project_Files\\txtsql\\agents\\agents.py", line 886, in invoke\n    model = self.get_model(json_model=True)\n  File "D:\\versa\\project_Files\\txtsql\\agents\\agents.py", line 79, in get_model\n    return CustomOpenAIWrapper(model=self.model, temperature=self.temperature, response_format={"type": "json_object"})\n  File "D:\\versa\\project_Files\\txtsql\\models\\openai_models.py", line 65, in __init__\n    self.client = get_client()  # Get client when needed\n  File "D:\\versa\\project_Files\\txtsql\\models\\openai_models.py", line 25, in get_client\n    raise ValueError("OpenAI API key not found in config or environment variables")\nValueError: OpenAI API key not found in config or environment variables\n', 'component': 'PlannerAgent', 'state': {}, 'recommendations': ['Review error logs for more details', 'Check state values for inconsistencies', 'Contact support if issue persists']}
2025-05-11 19:26:44,528 - DEBUG - STDOUT: 
==== SELECTOR NODE START ====
2025-05-11 19:26:44,529 - DEBUG - STDOUT: Input state: user_question=list all the interfaces
2025-05-11 19:26:44,530 - DEBUG - STDOUT: Current execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner']
2025-05-11 19:26:44,535 - DEBUG - STDOUT: Planner response received: {
  "error_type": "NON_FATAL",
  "error_message": "OpenAI API key not found in config or environment variables",
  "timestamp": "2025-05-11T19:26:44.348504",
  "stack_trace": "Traceback (most recent call last):\n  File \"D:\\versa\\project_Files\\txtsql\\agents\\agents.py\", line 886, in invoke\n    model = self.get_model(json_model=True)\n  File \"D:\\versa\\project_Files\\txtsql\\agents\\agents.py\", line 79, in get_model\n    return CustomOpenAIWrapper(model=self.model, temperature=self.temperature, response_format={\"type\": \"json_object\"})\n  File \"D:\\versa\\project_Files\\txtsql\\models\\openai_models.py\", line 65, in __init__\n    self.client = get_client()  # Get client when needed\n  File \"D:\\versa\\project_Files\\txtsql\\models\\openai_models.py\", line 25, in get_client\n    raise ValueError(\"OpenAI API key not found in config or environment variables\")\nValueError: OpenAI API key not found in config or environment variables\n",
  "component": "PlannerAgent",
  "state": {},
  "recommendations": [
    "Review error logs for more details",
    "Check state values for inconsistencies",
    "Contact support if issue persists"
  ]
}
2025-05-11 19:26:44,546 - DEBUG - STDOUT: Selector is processing planner response for question: 'list all the interfaces'
2025-05-11 19:26:44,548 - DEBUG - STDOUT: NOTE: The selector node is currently simplified and doesn't use LLM.
2025-05-11 19:26:44,551 - DEBUG - STDOUT: It simply passes through to the SQLGenerator without making actual selections.
2025-05-11 19:26:44,554 - DEBUG - STDOUT: Selector node output: current_agent=SQLGenerator
2025-05-11 19:26:44,554 - DEBUG - STDOUT: Selector response being sent to SQLGenerator: {
  "raw": "Selection completed",
  "selected_schemas": {},
  "selected_tool": "sql_query",
  "selected_datasource": "information_schema.tables",
  "information_needed": "Table listing",
  "reason_for_selection": "Direct database query is the most efficient way to list tables",
  "query_parameters": {
    "columns": [
      "table_schema",
      "table_name"
    ],
    "filters": "table_type = 'BASE TABLE'"
  }
}
2025-05-11 19:26:44,563 - DEBUG - STDOUT: ==== SELECTOR NODE END ====
2025-05-11 19:26:44,566 - INFO - Processing agent: selector
2025-05-11 19:26:44,567 - DEBUG - Event type: <class 'langgraph.pregel.io.AddableUpdatesDict'>
2025-05-11 19:26:44,570 - DEBUG - Event keys: dict_keys(['selector'])
2025-05-11 19:26:44,572 - DEBUG - Execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector']
2025-05-11 19:26:44,573 - DEBUG - selector response: {'raw': 'Selection completed', 'selected_schemas': {}, 'selected_tool': 'sql_query', 'selected_datasource': 'information_schema.tables', 'information_needed': 'Table listing', 'reason_for_selection': 'Direct database query is the most efficient way to list tables', 'query_parameters': {'columns': ['table_schema', 'table_name'], 'filters': "table_type = 'BASE TABLE'"}}
2025-05-11 19:26:44,576 - DEBUG - STDOUT: 
==== SQL GENERATOR NODE START ====
2025-05-11 19:26:44,578 - DEBUG - STDOUT: Input state: user_question=list all the interfaces
2025-05-11 19:26:44,580 - DEBUG - STDOUT: Current execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector']
2025-05-11 19:26:44,584 - DEBUG - STDOUT: Selector response received: {
  "raw": "Selection completed",
  "selected_schemas": {},
  "selected_tool": "sql_query",
  "selected_datasource": "information_schema.tables",
  "information_needed": "Table listing",
  "reason_for_selection": "Direct database query is the most efficient way to list tables",
  "query_parameters": {
    "columns": [
      "table_schema",
      "table_name"
    ],
    "filters": "table_type = 'BASE TABLE'"
  }
}
2025-05-11 19:26:44,592 - DEBUG - STDOUT: Created SQLGenerator with model=chatgpt-4o-latest, server=openai
2025-05-11 19:26:44,595 - DEBUG - STDOUT: Invoking SQLGenerator with user_question: 'list all the interfaces'
2025-05-11 19:26:44,598 - DEBUG - STDOUT: SQLGenerator returned response: {
  "sql_generator_response": {
    "sql_query": "SELECT DISTINCT table_schema, table_name, column_name \n                FROM information_schema.columns \n                WHERE column_name ILIKE '%interface%'\n                AND table_schema NOT IN ('pg_catalog', 'information_schema')\n                ORDER BY table_schema, table_name;",
    "explanation": "Query to discover interface-related columns across all schemas",
    "validation_checks": [
      "Query syntax validated",
      "Schema and table specified",
      "Column list validated",
      "WHERE clause included",
      "Results limited for safety"
    ],
    "query_type": "interface_list",
    "estimated_complexity": "LOW",
    "required_indexes": [],
    "metadata": {
      "generated_at": "2025-05-11 19:26:44.598104",
      "validation_status": "valid",
      "has_limit": false,
      "has_order": true
    }
  }
}
2025-05-11 19:26:44,608 - DEBUG - STDOUT: SQL Generator node output: current_agent=reviewer
2025-05-11 19:26:44,610 - DEBUG - STDOUT: SQL query generated: SELECT DISTINCT table_schema, table_name, column_name 
                FROM information_schema.columns 
                WHERE column_name ILIKE '%interface%'
                AND table_schema NOT IN ('pg_catalog', 'information_schema')
                ORDER BY table_schema, table_name;
2025-05-11 19:26:44,613 - DEBUG - STDOUT: SQL Generator response being sent to reviewer: {
  "sql_generator_response": {
    "sql_query": "SELECT DISTINCT table_schema, table_name, column_name \n                FROM information_schema.columns \n                WHERE column_name ILIKE '%interface%'\n                AND table_schema NOT IN ('pg_catalog', 'information_schema')\n                ORDER BY table_schema, table_name;",
    "explanation": "Query to discover interface-related columns across all schemas",
    "validation_checks": [
      "Query syntax validated",
      "Schema and table specified",
      "Column list validated",
      "WHERE clause included",
      "Results limited for safety"
    ],
    "query_type": "interface_list",
    "estimated_complexity": "LOW",
    "required_indexes": [],
    "metadata": {
      "generated_at": "2025-05-11 19:26:44.598104",
      "validation_status": "valid",
      "has_limit": false,
      "has_order": true
    }
  }
}
2025-05-11 19:26:44,622 - DEBUG - STDOUT: ==== SQL GENERATOR NODE END ====
2025-05-11 19:26:44,628 - INFO - Processing agent: SQLGenerator
2025-05-11 19:26:44,629 - DEBUG - Event type: <class 'langgraph.pregel.io.AddableUpdatesDict'>
2025-05-11 19:26:44,629 - DEBUG - Event keys: dict_keys(['SQLGenerator'])
2025-05-11 19:26:44,631 - DEBUG - Execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator']
2025-05-11 19:26:44,633 - DEBUG - SQLGenerator response: {'sql_generator_response': {'sql_query': "SELECT DISTINCT table_schema, table_name, column_name \n                FROM information_schema.columns \n                WHERE column_name ILIKE '%interface%'\n                AND table_schema NOT IN ('pg_catalog', 'information_schema')\n                ORDER BY table_schema, table_name;", 'explanation': 'Query to discover interface-related columns across all schemas', 'validation_checks': ['Query syntax validated', 'Schema and table specified', 'Column list validated', 'WHERE clause included', 'Results limited for safety'], 'query_type': 'interface_list', 'estimated_complexity': 'LOW', 'required_indexes': [], 'metadata': {'generated_at': '2025-05-11 19:26:44.598104', 'validation_status': 'valid', 'has_limit': False, 'has_order': True}}}
2025-05-11 19:26:44,636 - DEBUG - STDOUT: 
==== REVIEWER NODE START ====
2025-05-11 19:26:44,638 - DEBUG - STDOUT: Input state: user_question=list all the interfaces
2025-05-11 19:26:44,638 - DEBUG - STDOUT: Current execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator']
2025-05-11 19:26:44,644 - DEBUG - STDOUT: SQL query to review: SELECT DISTINCT table_schema, table_name, column_name 
                FROM information_schema.columns 
                WHERE column_name ILIKE '%interface%'
                AND table_schema NOT IN ('pg_catalog', 'information_schema')
                ORDER BY table_schema, table_name;
2025-05-11 19:26:44,647 - DEBUG - STDOUT: SQLGenerator response received: {
  "sql_generator_response": {
    "sql_query": "SELECT DISTINCT table_schema, table_name, column_name \n                FROM information_schema.columns \n                WHERE column_name ILIKE '%interface%'\n                AND table_schema NOT IN ('pg_catalog', 'information_schema')\n                ORDER BY table_schema, table_name;",
    "explanation": "Query to discover interface-related columns across all schemas",
    "validation_checks": [
      "Query syntax validated",
      "Schema and table specified",
      "Column list validated",
      "WHERE clause included",
      "Results limited for safety"
    ],
    "query_type": "interface_list",
    "estimated_complexity": "LOW",
    "required_indexes": [],
    "metadata": {
      "generated_at": "2025-05-11 19:26:44.598104",
      "validation_status": "valid",
      "has_limit": false,
      "has_order": true
    }
  }
}
2025-05-11 19:26:44,662 - DEBUG - STDOUT: Reviewer is analyzing SQL query for question: 'list all the interfaces'
2025-05-11 19:26:44,663 - DEBUG - STDOUT: Using LLM-based ReviewerAgent to analyze the SQL query
2025-05-11 19:26:44,667 - DEBUG - STDOUT: Created ReviewerAgent with model=chatgpt-4o-latest, server=openai
2025-05-11 19:26:44,669 - DEBUG - STDOUT: Invoking ReviewerAgent with user_question: 'list all the interfaces' and sql_query: 'SELECT DISTINCT table_schema, table_name, column_name 
                FROM information_schema.columns 
                WHERE column_name ILIKE '%interface%'
                AND table_schema NOT IN ('pg_catalog', 'information_schema')
                ORDER BY table_schema, table_name;'
2025-05-11 19:26:44,673 - DEBUG - STDOUT: ReviewerAgent returned review: {
  "reviewer_response": {
    "is_correct": false,
    "issues": [
      "No LIMIT clause"
    ],
    "suggestions": [
      "Add LIMIT clause to prevent large result sets",
      "Ensure proper indexes exist for WHERE clause columns",
      "Consider adding indexes on WHERE clause columns",
      "Consider adding appropriate WHERE clauses",
      "Use explicit column names instead of *",
      "Add ORDER BY for consistent results"
    ],
    "explanation": "Query validation found issues: No LIMIT clause",
    "security_concerns": [],
    "performance_impact": "MEDIUM",
    "confidence_score": 1.0,
    "metadata": {
      "reviewed_at": "2025-05-11 19:26:44.673211",
      "query_type": "SELECT",
      "has_joins": false,
      "has_where": true,
      "has_limit": false
    }
  }
}
2025-05-11 19:26:44,696 - DEBUG - STDOUT: Reviewer node output: current_agent=sql_executor
2025-05-11 19:26:44,698 - DEBUG - STDOUT: Reviewer response being sent to sql_executor: {
  "reviewer_response": {
    "is_correct": false,
    "issues": [
      "No LIMIT clause"
    ],
    "suggestions": [
      "Add LIMIT clause to prevent large result sets",
      "Ensure proper indexes exist for WHERE clause columns",
      "Consider adding indexes on WHERE clause columns",
      "Consider adding appropriate WHERE clauses",
      "Use explicit column names instead of *",
      "Add ORDER BY for consistent results"
    ],
    "explanation": "Query validation found issues: No LIMIT clause",
    "security_concerns": [],
    "performance_impact": "MEDIUM",
    "confidence_score": 1.0,
    "metadata": {
      "reviewed_at": "2025-05-11 19:26:44.673211",
      "query_type": "SELECT",
      "has_joins": false,
      "has_where": true,
      "has_limit": false
    }
  }
}
2025-05-11 19:26:44,720 - DEBUG - STDOUT: ==== REVIEWER NODE END ====
2025-05-11 19:26:44,725 - INFO - Processing agent: reviewer
2025-05-11 19:26:44,728 - DEBUG - Event type: <class 'langgraph.pregel.io.AddableUpdatesDict'>
2025-05-11 19:26:44,735 - DEBUG - Event keys: dict_keys(['reviewer'])
2025-05-11 19:26:44,737 - DEBUG - Execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer']
2025-05-11 19:26:44,742 - DEBUG - reviewer response: {'reviewer_response': {'is_correct': False, 'issues': ['No LIMIT clause'], 'suggestions': ['Add LIMIT clause to prevent large result sets', 'Ensure proper indexes exist for WHERE clause columns', 'Consider adding indexes on WHERE clause columns', 'Consider adding appropriate WHERE clauses', 'Use explicit column names instead of *', 'Add ORDER BY for consistent results'], 'explanation': 'Query validation found issues: No LIMIT clause', 'security_concerns': [], 'performance_impact': 'MEDIUM', 'confidence_score': 1.0, 'metadata': {'reviewed_at': '2025-05-11 19:26:44.673211', 'query_type': 'SELECT', 'has_joins': False, 'has_where': True, 'has_limit': False}}}
2025-05-11 19:26:44,747 - DEBUG - STDOUT: 
==== SQL EXECUTOR NODE START ====
2025-05-11 19:26:44,749 - DEBUG - STDOUT: Input state: user_question=list all the interfaces
2025-05-11 19:26:44,752 - DEBUG - STDOUT: Current execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer']
2025-05-11 19:26:44,756 - DEBUG - STDOUT: SQL query to execute: SELECT DISTINCT table_schema, table_name, column_name 
                FROM information_schema.columns 
                WHERE column_name ILIKE '%interface%'
                AND table_schema NOT IN ('pg_catalog', 'information_schema')
                ORDER BY table_schema, table_name;
2025-05-11 19:26:44,763 - DEBUG - STDOUT: Reviewer response received: {
  "reviewer_response": {
    "is_correct": false,
    "issues": [
      "No LIMIT clause"
    ],
    "suggestions": [
      "Add LIMIT clause to prevent large result sets",
      "Ensure proper indexes exist for WHERE clause columns",
      "Consider adding indexes on WHERE clause columns",
      "Consider adding appropriate WHERE clauses",
      "Use explicit column names instead of *",
      "Add ORDER BY for consistent results"
    ],
    "explanation": "Query validation found issues: No LIMIT clause",
    "security_concerns": [],
    "performance_impact": "MEDIUM",
    "confidence_score": 1.0,
    "metadata": {
      "reviewed_at": "2025-05-11 19:26:44.673211",
      "query_type": "SELECT",
      "has_joins": false,
      "has_where": true,
      "has_limit": false
    }
  }
}
2025-05-11 19:26:44,780 - DEBUG - STDOUT: SQL Executor is processing SQL query: 'SELECT DISTINCT table_schema, table_name, column_name 
                FROM information_schema.columns 
                WHERE column_name ILIKE '%interface%'
                AND table_schema NOT IN ('pg_catalog', 'information_schema')
                ORDER BY table_schema, table_name;'
2025-05-11 19:26:44,784 - DEBUG - STDOUT: Executing SQL query against database: 'SELECT DISTINCT table_schema, table_name, column_name 
                FROM information_schema.columns 
                WHERE column_name ILIKE '%interface%'
                AND table_schema NOT IN ('pg_catalog', 'information_schema')
                ORDER BY table_schema, table_name;'
2025-05-11 19:26:44,789 - DEBUG - STDOUT: NOTE: SQL Executor does not use LLM. It directly executes the SQL query against the database.
2025-05-11 19:26:44,790 - DEBUG - STDOUT: Attempting database connection to localhost:5432/new as postgres
2025-05-11 19:26:44,861 - DEBUG - STDOUT: Successfully connected to database new at localhost:5432
2025-05-11 19:26:44,864 - DEBUG - STDOUT: Database is available
2025-05-11 19:26:44,866 - DEBUG - STDOUT: Attempting database connection to localhost:5432/new as postgres
2025-05-11 19:26:44,945 - DEBUG - STDOUT: Successfully connected to database new at localhost:5432
2025-05-11 19:26:44,985 - DEBUG - STDOUT: Successfully executed query against actual database
2025-05-11 19:26:44,985 - DEBUG - STDOUT: SQL query execution results: {
  "column_names": [
    "table_schema",
    "table_name",
    "column_name"
  ],
  "rows": [
    [
      "dev",
      "abap_integration_engine_interfaces",
      "abap_integration_engine_interface_destination"
    ],
    [
      "dev",
      "pro_agreements",
      "interface"
    ],
    [
      "dev",
      "pro_integrated_configuration_interfaces",
      "interface"
    ],
    [
      "dev",
      "pro_integrated_configuration_interfaces",
      "interface_namespace"
    ],
    [
      "dev",
      "pro_integrated_configuration_interfaces",
      "pro_integrated_configuration_interface_channel"
    ],
    [
      "dev",
      "pro_integrated_configuration_rules",
      "pro_integrated_configuration_interface_rules"
    ],
    [
      "dev",
      "pro_integrated_configurations",
      "interface"
    ],
    [
      "dev",
      "pro_performance_data",
      "interface_name"
    ],
    [
      "dev",
      "pro_performance_stats",
      "interface_name"
    ],
    [
      "dev",
      "system_mappings",
      "interface_pattern"
    ]
  ],
  "row_count": 10,
  "execution_time": 0.039023,
  "query": "SELECT DISTINCT table_schema, table_name, column_name \n                FROM information_schema.columns \n                WHERE column_name ILIKE '%interface%'\n                AND table_schema NOT IN ('pg_catalog', 'information_schema')\n                ORDER BY table_schema, table_name;",
  "status": "success"
}
2025-05-11 19:26:45,011 - DEBUG - STDOUT: SQL Executor node output: current_agent=router
2025-05-11 19:26:45,012 - DEBUG - STDOUT: SQL query results summary: status=success, rows=10
2025-05-11 19:26:45,013 - DEBUG - STDOUT: ==== SQL EXECUTOR NODE END ====
2025-05-11 19:26:45,017 - INFO - Processing agent: sql_executor
2025-05-11 19:26:45,018 - DEBUG - Event type: <class 'langgraph.pregel.io.AddableUpdatesDict'>
2025-05-11 19:26:45,019 - DEBUG - Event keys: dict_keys(['sql_executor'])
2025-05-11 19:26:45,020 - DEBUG - Execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor']
2025-05-11 19:26:45,022 - DEBUG - STDOUT: 
==== ROUTER NODE START ====
2025-05-11 19:26:45,024 - DEBUG - STDOUT: Input state: user_question=list all the interfaces
2025-05-11 19:26:45,026 - DEBUG - STDOUT: Current execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor']
2025-05-11 19:26:45,029 - DEBUG - STDOUT: RouterAgent returned decision: {
  "router_response": {
    "route_to": "planner",
    "reason": "Starting new workflow",
    "feedback": "Initializing workflow with planner",
    "state_updates": {
      "workflow_started": true,
      "start_time": "2025-05-11T19:26:45.029839"
    },
    "confidence_score": 1.0,
    "requires_human_input": false
  }
}
2025-05-11 19:26:45,036 - DEBUG - STDOUT: Route decision: planner
2025-05-11 19:26:45,038 - DEBUG - STDOUT: Router node output: current_agent=planner
2025-05-11 19:26:45,039 - DEBUG - STDOUT: Router response: {
  "route_to": "planner",
  "reason": "Starting new workflow",
  "feedback": "Initializing workflow with planner",
  "state_updates": {
    "workflow_started": true,
    "start_time": "2025-05-11T19:26:45.029839"
  },
  "confidence_score": 1.0,
  "requires_human_input": false
}
2025-05-11 19:26:45,045 - DEBUG - STDOUT: ==== ROUTER NODE END ====
2025-05-11 19:26:45,047 - DEBUG - STDOUT: RECURSION GUARD: Node planner visited 4 times. Forcing to end.
2025-05-11 19:26:45,050 - INFO - Processing agent: router
2025-05-11 19:26:45,051 - DEBUG - Event type: <class 'langgraph.pregel.io.AddableUpdatesDict'>
2025-05-11 19:26:45,052 - DEBUG - Event keys: dict_keys(['router'])
2025-05-11 19:26:45,054 - DEBUG - Execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router']
2025-05-11 19:26:45,057 - DEBUG - router response: {'route_to': 'planner', 'reason': 'Starting new workflow', 'feedback': 'Initializing workflow with planner', 'state_updates': {'workflow_started': True, 'start_time': '2025-05-11T19:26:45.029839'}, 'confidence_score': 1.0, 'requires_human_input': False}
2025-05-11 19:26:45,059 - DEBUG - STDOUT: 
==== END NODE START ====
2025-05-11 19:26:45,060 - DEBUG - STDOUT: Processing final state
2025-05-11 19:26:45,063 - DEBUG - STDOUT: Creating default final report
2025-05-11 19:26:45,064 - DEBUG - STDOUT: Final report prepared successfully
2025-05-11 19:26:45,069 - DEBUG - STDOUT: ==== END NODE END ====
2025-05-11 19:26:45,075 - INFO - Processing agent: end
2025-05-11 19:26:45,076 - DEBUG - Event type: <class 'langgraph.pregel.io.AddableUpdatesDict'>
2025-05-11 19:26:45,077 - DEBUG - Event keys: dict_keys(['end'])
2025-05-11 19:26:45,078 - DEBUG - Execution path: ['planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router', 'planner', 'selector', 'SQLGenerator', 'reviewer', 'sql_executor', 'router']
2025-05-11 19:26:45,082 - DEBUG - Final state type: <class 'langgraph.pregel.io.AddableUpdatesDict'>
2025-05-11 19:26:45,112 - DEBUG - Final state keys: dict_keys(['end'])
2025-05-11 19:26:45,147 - DEBUG - End node type: <class 'dict'>
2025-05-11 19:26:45,185 - DEBUG - End node keys: dict_keys(['current_agent', 'user_question', 'selected_schema', 'tool_responses', 'execution_path', 'errors', 'is_error_state', 'planner_response', 'selector_response', 'SQLGenerator_response', 'reviewer_response', 'router_response', 'final_report_response', 'final_report_data', 'schemas', 'sql_query', 'sql_query_results', 'previous_selections', 'previous_reports', 'start_time', 'retry_counts', 'last_successful_state', 'end_chain', 'current_node', 'iteration_count', 'error_count', 'last_error', 'last_success', 'metadata', 'workflow_completed', 'completion_timestamp'])
2025-05-11 19:26:45,198 - INFO - SQL query results: {'column_names': ['table_schema', 'table_name', 'column_name'], 'rows': [('dev', 'abap_integration_engine_interfaces', 'abap_integration_engine_interface_destination'), ('dev', 'pro_agreements', 'interface'), ('dev', 'pro_integrated_configuration_interfaces', 'interface'), ('dev', 'pro_integrated_configuration_interfaces', 'interface_namespace'), ('dev', 'pro_integrated_configuration_interfaces', 'pro_integrated_configuration_interface_channel'), ('dev', 'pro_integrated_configuration_rules', 'pro_integrated_configuration_interface_rules'), ('dev', 'pro_integrated_configurations', 'interface'), ('dev', 'pro_performance_data', 'interface_name'), ('dev', 'pro_performance_stats', 'interface_name'), ('dev', 'system_mappings', 'interface_pattern')], 'row_count': 10, 'execution_time': 0.039023, 'query': "SELECT DISTINCT table_schema, table_name, column_name \n                FROM information_schema.columns \n                WHERE column_name ILIKE '%interface%'\n                AND table_schema NOT IN ('pg_catalog', 'information_schema')\n                ORDER BY table_schema, table_name;", 'status': 'success'}
2025-05-11 19:26:45,238 - INFO - SQL query: SELECT DISTINCT table_schema, table_name, column_name 
                FROM information_schema.columns 
                WHERE column_name ILIKE '%interface%'
                AND table_schema NOT IN ('pg_catalog', 'information_schema')
                ORDER BY table_schema, table_name;
